// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Msg.proto

#ifndef PROTOBUF_Msg_2eproto__INCLUDED
#define PROTOBUF_Msg_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_Msg_2eproto();
void protobuf_AssignDesc_Msg_2eproto();
void protobuf_ShutdownFile_Msg_2eproto();

class Msg_Login_C2S;
class Msg_Login_S2C;
class Msg_WorldChat_C2S;
class Msg_WorldChat_S2C;
class Msg_RoomChat_C2R;
class Msg_RoomChat_R2C;
class Msg_PrivateChat_C2C;
class Msg_RoomOperate_C2S;
class Msg_RoomOperate_S2C;
class Msg_StartBattle_C2S;
class Msg_StartBattle_S2C;
class Msg_OriginHandCards_S2C;
class Msg_GameUpdate_C2S;
class Msg_GameUpdate_S2C;
class Msg_Surrender_C2S;
class Msg_Gameover_S2C;
class Msg_RoomList_S2C;
class Msg_AccountMsg_C2S;
class Msg_AccountMsg_S2C;
class protoaccount;
class protocard;
class protoRoom;

enum GamePattern {
  Standard = 0,
  Rank = 1
};
bool GamePattern_IsValid(int value);
const GamePattern GamePattern_MIN = Standard;
const GamePattern GamePattern_MAX = Rank;
const int GamePattern_ARRAYSIZE = GamePattern_MAX + 1;

const ::google::protobuf::EnumDescriptor* GamePattern_descriptor();
inline const ::std::string& GamePattern_Name(GamePattern value) {
  return ::google::protobuf::internal::NameOfEnum(
    GamePattern_descriptor(), value);
}
inline bool GamePattern_Parse(
    const ::std::string& name, GamePattern* value) {
  return ::google::protobuf::internal::ParseNamedEnum<GamePattern>(
    GamePattern_descriptor(), name, value);
}
enum CardAttribute {
  none = 0,
  fire = 1,
  water = 2,
  wood = 3,
  light = 4,
  dark = 5
};
bool CardAttribute_IsValid(int value);
const CardAttribute CardAttribute_MIN = none;
const CardAttribute CardAttribute_MAX = dark;
const int CardAttribute_ARRAYSIZE = CardAttribute_MAX + 1;

const ::google::protobuf::EnumDescriptor* CardAttribute_descriptor();
inline const ::std::string& CardAttribute_Name(CardAttribute value) {
  return ::google::protobuf::internal::NameOfEnum(
    CardAttribute_descriptor(), value);
}
inline bool CardAttribute_Parse(
    const ::std::string& name, CardAttribute* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CardAttribute>(
    CardAttribute_descriptor(), name, value);
}
enum MsgType {
  LOGIN_C2S = 0,
  LOGIN_S2C = 1,
  WORLDCHAT_C2S = 2,
  WORLDCHAT_S2C = 3,
  ROOMCHAT_C2R = 4,
  ROOMCHAT_R2C = 5,
  PRIVATECHAT_C2C = 6,
  RoomOperate_C2S = 7,
  RoomOperate_S2C = 8,
  StartBattle_C2S = 9,
  StartBattle_S2C = 10,
  GameUpdate_C2S = 11,
  GameUpdate_S2C = 12,
  Surrender_C2S = 13,
  GameOver_S2C = 14,
  OriginHandCards_S2C = 15,
  RoomList_S2C = 16,
  AccountMsg_C2S = 17,
  AccountMsg_S2C = 18
};
bool MsgType_IsValid(int value);
const MsgType MsgType_MIN = LOGIN_C2S;
const MsgType MsgType_MAX = AccountMsg_S2C;
const int MsgType_ARRAYSIZE = MsgType_MAX + 1;

const ::google::protobuf::EnumDescriptor* MsgType_descriptor();
inline const ::std::string& MsgType_Name(MsgType value) {
  return ::google::protobuf::internal::NameOfEnum(
    MsgType_descriptor(), value);
}
inline bool MsgType_Parse(
    const ::std::string& name, MsgType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MsgType>(
    MsgType_descriptor(), name, value);
}
enum RoomOperateType {
  CREATEROOM = 0,
  JOINROOM = 1,
  EXITROOM = 2,
  ROOMMESSAGE = 3,
  ROOMLIST = 4
};
bool RoomOperateType_IsValid(int value);
const RoomOperateType RoomOperateType_MIN = CREATEROOM;
const RoomOperateType RoomOperateType_MAX = ROOMLIST;
const int RoomOperateType_ARRAYSIZE = RoomOperateType_MAX + 1;

const ::google::protobuf::EnumDescriptor* RoomOperateType_descriptor();
inline const ::std::string& RoomOperateType_Name(RoomOperateType value) {
  return ::google::protobuf::internal::NameOfEnum(
    RoomOperateType_descriptor(), value);
}
inline bool RoomOperateType_Parse(
    const ::std::string& name, RoomOperateType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<RoomOperateType>(
    RoomOperateType_descriptor(), name, value);
}
// ===================================================================

class Msg_Login_C2S : public ::google::protobuf::Message {
 public:
  Msg_Login_C2S();
  virtual ~Msg_Login_C2S();

  Msg_Login_C2S(const Msg_Login_C2S& from);

  inline Msg_Login_C2S& operator=(const Msg_Login_C2S& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Msg_Login_C2S& default_instance();

  void Swap(Msg_Login_C2S* other);

  // implements Message ----------------------------------------------

  Msg_Login_C2S* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Msg_Login_C2S& from);
  void MergeFrom(const Msg_Login_C2S& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required fixed32 conMethod = 1;
  inline bool has_conmethod() const;
  inline void clear_conmethod();
  static const int kConMethodFieldNumber = 1;
  inline ::google::protobuf::uint32 conmethod() const;
  inline void set_conmethod(::google::protobuf::uint32 value);

  // required string szName = 2;
  inline bool has_szname() const;
  inline void clear_szname();
  static const int kSzNameFieldNumber = 2;
  inline const ::std::string& szname() const;
  inline void set_szname(const ::std::string& value);
  inline void set_szname(const char* value);
  inline void set_szname(const char* value, size_t size);
  inline ::std::string* mutable_szname();
  inline ::std::string* release_szname();
  inline void set_allocated_szname(::std::string* szname);

  // required string szPassWord = 3;
  inline bool has_szpassword() const;
  inline void clear_szpassword();
  static const int kSzPassWordFieldNumber = 3;
  inline const ::std::string& szpassword() const;
  inline void set_szpassword(const ::std::string& value);
  inline void set_szpassword(const char* value);
  inline void set_szpassword(const char* value, size_t size);
  inline ::std::string* mutable_szpassword();
  inline ::std::string* release_szpassword();
  inline void set_allocated_szpassword(::std::string* szpassword);

  // @@protoc_insertion_point(class_scope:Msg_Login_C2S)
 private:
  inline void set_has_conmethod();
  inline void clear_has_conmethod();
  inline void set_has_szname();
  inline void clear_has_szname();
  inline void set_has_szpassword();
  inline void clear_has_szpassword();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* szname_;
  ::std::string* szpassword_;
  ::google::protobuf::uint32 conmethod_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_Msg_2eproto();
  friend void protobuf_AssignDesc_Msg_2eproto();
  friend void protobuf_ShutdownFile_Msg_2eproto();

  void InitAsDefaultInstance();
  static Msg_Login_C2S* default_instance_;
};
// -------------------------------------------------------------------

class Msg_Login_S2C : public ::google::protobuf::Message {
 public:
  Msg_Login_S2C();
  virtual ~Msg_Login_S2C();

  Msg_Login_S2C(const Msg_Login_S2C& from);

  inline Msg_Login_S2C& operator=(const Msg_Login_S2C& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Msg_Login_S2C& default_instance();

  void Swap(Msg_Login_S2C* other);

  // implements Message ----------------------------------------------

  Msg_Login_S2C* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Msg_Login_S2C& from);
  void MergeFrom(const Msg_Login_S2C& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required fixed32 clientId = 1;
  inline bool has_clientid() const;
  inline void clear_clientid();
  static const int kClientIdFieldNumber = 1;
  inline ::google::protobuf::uint32 clientid() const;
  inline void set_clientid(::google::protobuf::uint32 value);

  // required bool conSuccess = 2;
  inline bool has_consuccess() const;
  inline void clear_consuccess();
  static const int kConSuccessFieldNumber = 2;
  inline bool consuccess() const;
  inline void set_consuccess(bool value);

  // @@protoc_insertion_point(class_scope:Msg_Login_S2C)
 private:
  inline void set_has_clientid();
  inline void clear_has_clientid();
  inline void set_has_consuccess();
  inline void clear_has_consuccess();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 clientid_;
  bool consuccess_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_Msg_2eproto();
  friend void protobuf_AssignDesc_Msg_2eproto();
  friend void protobuf_ShutdownFile_Msg_2eproto();

  void InitAsDefaultInstance();
  static Msg_Login_S2C* default_instance_;
};
// -------------------------------------------------------------------

class Msg_WorldChat_C2S : public ::google::protobuf::Message {
 public:
  Msg_WorldChat_C2S();
  virtual ~Msg_WorldChat_C2S();

  Msg_WorldChat_C2S(const Msg_WorldChat_C2S& from);

  inline Msg_WorldChat_C2S& operator=(const Msg_WorldChat_C2S& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Msg_WorldChat_C2S& default_instance();

  void Swap(Msg_WorldChat_C2S* other);

  // implements Message ----------------------------------------------

  Msg_WorldChat_C2S* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Msg_WorldChat_C2S& from);
  void MergeFrom(const Msg_WorldChat_C2S& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string szName = 1;
  inline bool has_szname() const;
  inline void clear_szname();
  static const int kSzNameFieldNumber = 1;
  inline const ::std::string& szname() const;
  inline void set_szname(const ::std::string& value);
  inline void set_szname(const char* value);
  inline void set_szname(const char* value, size_t size);
  inline ::std::string* mutable_szname();
  inline ::std::string* release_szname();
  inline void set_allocated_szname(::std::string* szname);

  // required fixed32 ID = 2;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIDFieldNumber = 2;
  inline ::google::protobuf::uint32 id() const;
  inline void set_id(::google::protobuf::uint32 value);

  // required string szText = 3;
  inline bool has_sztext() const;
  inline void clear_sztext();
  static const int kSzTextFieldNumber = 3;
  inline const ::std::string& sztext() const;
  inline void set_sztext(const ::std::string& value);
  inline void set_sztext(const char* value);
  inline void set_sztext(const char* value, size_t size);
  inline ::std::string* mutable_sztext();
  inline ::std::string* release_sztext();
  inline void set_allocated_sztext(::std::string* sztext);

  // @@protoc_insertion_point(class_scope:Msg_WorldChat_C2S)
 private:
  inline void set_has_szname();
  inline void clear_has_szname();
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_sztext();
  inline void clear_has_sztext();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* szname_;
  ::std::string* sztext_;
  ::google::protobuf::uint32 id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_Msg_2eproto();
  friend void protobuf_AssignDesc_Msg_2eproto();
  friend void protobuf_ShutdownFile_Msg_2eproto();

  void InitAsDefaultInstance();
  static Msg_WorldChat_C2S* default_instance_;
};
// -------------------------------------------------------------------

class Msg_WorldChat_S2C : public ::google::protobuf::Message {
 public:
  Msg_WorldChat_S2C();
  virtual ~Msg_WorldChat_S2C();

  Msg_WorldChat_S2C(const Msg_WorldChat_S2C& from);

  inline Msg_WorldChat_S2C& operator=(const Msg_WorldChat_S2C& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Msg_WorldChat_S2C& default_instance();

  void Swap(Msg_WorldChat_S2C* other);

  // implements Message ----------------------------------------------

  Msg_WorldChat_S2C* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Msg_WorldChat_S2C& from);
  void MergeFrom(const Msg_WorldChat_S2C& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string szName = 1;
  inline bool has_szname() const;
  inline void clear_szname();
  static const int kSzNameFieldNumber = 1;
  inline const ::std::string& szname() const;
  inline void set_szname(const ::std::string& value);
  inline void set_szname(const char* value);
  inline void set_szname(const char* value, size_t size);
  inline ::std::string* mutable_szname();
  inline ::std::string* release_szname();
  inline void set_allocated_szname(::std::string* szname);

  // required fixed32 ID = 2;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIDFieldNumber = 2;
  inline ::google::protobuf::uint32 id() const;
  inline void set_id(::google::protobuf::uint32 value);

  // required string szText = 3;
  inline bool has_sztext() const;
  inline void clear_sztext();
  static const int kSzTextFieldNumber = 3;
  inline const ::std::string& sztext() const;
  inline void set_sztext(const ::std::string& value);
  inline void set_sztext(const char* value);
  inline void set_sztext(const char* value, size_t size);
  inline ::std::string* mutable_sztext();
  inline ::std::string* release_sztext();
  inline void set_allocated_sztext(::std::string* sztext);

  // @@protoc_insertion_point(class_scope:Msg_WorldChat_S2C)
 private:
  inline void set_has_szname();
  inline void clear_has_szname();
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_sztext();
  inline void clear_has_sztext();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* szname_;
  ::std::string* sztext_;
  ::google::protobuf::uint32 id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_Msg_2eproto();
  friend void protobuf_AssignDesc_Msg_2eproto();
  friend void protobuf_ShutdownFile_Msg_2eproto();

  void InitAsDefaultInstance();
  static Msg_WorldChat_S2C* default_instance_;
};
// -------------------------------------------------------------------

class Msg_RoomChat_C2R : public ::google::protobuf::Message {
 public:
  Msg_RoomChat_C2R();
  virtual ~Msg_RoomChat_C2R();

  Msg_RoomChat_C2R(const Msg_RoomChat_C2R& from);

  inline Msg_RoomChat_C2R& operator=(const Msg_RoomChat_C2R& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Msg_RoomChat_C2R& default_instance();

  void Swap(Msg_RoomChat_C2R* other);

  // implements Message ----------------------------------------------

  Msg_RoomChat_C2R* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Msg_RoomChat_C2R& from);
  void MergeFrom(const Msg_RoomChat_C2R& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string szName = 1;
  inline bool has_szname() const;
  inline void clear_szname();
  static const int kSzNameFieldNumber = 1;
  inline const ::std::string& szname() const;
  inline void set_szname(const ::std::string& value);
  inline void set_szname(const char* value);
  inline void set_szname(const char* value, size_t size);
  inline ::std::string* mutable_szname();
  inline ::std::string* release_szname();
  inline void set_allocated_szname(::std::string* szname);

  // required fixed32 ID = 2;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIDFieldNumber = 2;
  inline ::google::protobuf::uint32 id() const;
  inline void set_id(::google::protobuf::uint32 value);

  // required fixed32 roomID = 3;
  inline bool has_roomid() const;
  inline void clear_roomid();
  static const int kRoomIDFieldNumber = 3;
  inline ::google::protobuf::uint32 roomid() const;
  inline void set_roomid(::google::protobuf::uint32 value);

  // required string szText = 4;
  inline bool has_sztext() const;
  inline void clear_sztext();
  static const int kSzTextFieldNumber = 4;
  inline const ::std::string& sztext() const;
  inline void set_sztext(const ::std::string& value);
  inline void set_sztext(const char* value);
  inline void set_sztext(const char* value, size_t size);
  inline ::std::string* mutable_sztext();
  inline ::std::string* release_sztext();
  inline void set_allocated_sztext(::std::string* sztext);

  // @@protoc_insertion_point(class_scope:Msg_RoomChat_C2R)
 private:
  inline void set_has_szname();
  inline void clear_has_szname();
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_roomid();
  inline void clear_has_roomid();
  inline void set_has_sztext();
  inline void clear_has_sztext();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* szname_;
  ::google::protobuf::uint32 id_;
  ::google::protobuf::uint32 roomid_;
  ::std::string* sztext_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_Msg_2eproto();
  friend void protobuf_AssignDesc_Msg_2eproto();
  friend void protobuf_ShutdownFile_Msg_2eproto();

  void InitAsDefaultInstance();
  static Msg_RoomChat_C2R* default_instance_;
};
// -------------------------------------------------------------------

class Msg_RoomChat_R2C : public ::google::protobuf::Message {
 public:
  Msg_RoomChat_R2C();
  virtual ~Msg_RoomChat_R2C();

  Msg_RoomChat_R2C(const Msg_RoomChat_R2C& from);

  inline Msg_RoomChat_R2C& operator=(const Msg_RoomChat_R2C& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Msg_RoomChat_R2C& default_instance();

  void Swap(Msg_RoomChat_R2C* other);

  // implements Message ----------------------------------------------

  Msg_RoomChat_R2C* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Msg_RoomChat_R2C& from);
  void MergeFrom(const Msg_RoomChat_R2C& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string szName = 1;
  inline bool has_szname() const;
  inline void clear_szname();
  static const int kSzNameFieldNumber = 1;
  inline const ::std::string& szname() const;
  inline void set_szname(const ::std::string& value);
  inline void set_szname(const char* value);
  inline void set_szname(const char* value, size_t size);
  inline ::std::string* mutable_szname();
  inline ::std::string* release_szname();
  inline void set_allocated_szname(::std::string* szname);

  // required fixed32 ID = 2;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIDFieldNumber = 2;
  inline ::google::protobuf::uint32 id() const;
  inline void set_id(::google::protobuf::uint32 value);

  // required fixed32 roomID = 3;
  inline bool has_roomid() const;
  inline void clear_roomid();
  static const int kRoomIDFieldNumber = 3;
  inline ::google::protobuf::uint32 roomid() const;
  inline void set_roomid(::google::protobuf::uint32 value);

  // required string szText = 4;
  inline bool has_sztext() const;
  inline void clear_sztext();
  static const int kSzTextFieldNumber = 4;
  inline const ::std::string& sztext() const;
  inline void set_sztext(const ::std::string& value);
  inline void set_sztext(const char* value);
  inline void set_sztext(const char* value, size_t size);
  inline ::std::string* mutable_sztext();
  inline ::std::string* release_sztext();
  inline void set_allocated_sztext(::std::string* sztext);

  // @@protoc_insertion_point(class_scope:Msg_RoomChat_R2C)
 private:
  inline void set_has_szname();
  inline void clear_has_szname();
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_roomid();
  inline void clear_has_roomid();
  inline void set_has_sztext();
  inline void clear_has_sztext();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* szname_;
  ::google::protobuf::uint32 id_;
  ::google::protobuf::uint32 roomid_;
  ::std::string* sztext_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_Msg_2eproto();
  friend void protobuf_AssignDesc_Msg_2eproto();
  friend void protobuf_ShutdownFile_Msg_2eproto();

  void InitAsDefaultInstance();
  static Msg_RoomChat_R2C* default_instance_;
};
// -------------------------------------------------------------------

class Msg_PrivateChat_C2C : public ::google::protobuf::Message {
 public:
  Msg_PrivateChat_C2C();
  virtual ~Msg_PrivateChat_C2C();

  Msg_PrivateChat_C2C(const Msg_PrivateChat_C2C& from);

  inline Msg_PrivateChat_C2C& operator=(const Msg_PrivateChat_C2C& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Msg_PrivateChat_C2C& default_instance();

  void Swap(Msg_PrivateChat_C2C* other);

  // implements Message ----------------------------------------------

  Msg_PrivateChat_C2C* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Msg_PrivateChat_C2C& from);
  void MergeFrom(const Msg_PrivateChat_C2C& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string szName = 1;
  inline bool has_szname() const;
  inline void clear_szname();
  static const int kSzNameFieldNumber = 1;
  inline const ::std::string& szname() const;
  inline void set_szname(const ::std::string& value);
  inline void set_szname(const char* value);
  inline void set_szname(const char* value, size_t size);
  inline ::std::string* mutable_szname();
  inline ::std::string* release_szname();
  inline void set_allocated_szname(::std::string* szname);

  // required fixed32 ID = 2;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIDFieldNumber = 2;
  inline ::google::protobuf::uint32 id() const;
  inline void set_id(::google::protobuf::uint32 value);

  // required fixed32 targetID = 3;
  inline bool has_targetid() const;
  inline void clear_targetid();
  static const int kTargetIDFieldNumber = 3;
  inline ::google::protobuf::uint32 targetid() const;
  inline void set_targetid(::google::protobuf::uint32 value);

  // required string szText = 4;
  inline bool has_sztext() const;
  inline void clear_sztext();
  static const int kSzTextFieldNumber = 4;
  inline const ::std::string& sztext() const;
  inline void set_sztext(const ::std::string& value);
  inline void set_sztext(const char* value);
  inline void set_sztext(const char* value, size_t size);
  inline ::std::string* mutable_sztext();
  inline ::std::string* release_sztext();
  inline void set_allocated_sztext(::std::string* sztext);

  // @@protoc_insertion_point(class_scope:Msg_PrivateChat_C2C)
 private:
  inline void set_has_szname();
  inline void clear_has_szname();
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_targetid();
  inline void clear_has_targetid();
  inline void set_has_sztext();
  inline void clear_has_sztext();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* szname_;
  ::google::protobuf::uint32 id_;
  ::google::protobuf::uint32 targetid_;
  ::std::string* sztext_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_Msg_2eproto();
  friend void protobuf_AssignDesc_Msg_2eproto();
  friend void protobuf_ShutdownFile_Msg_2eproto();

  void InitAsDefaultInstance();
  static Msg_PrivateChat_C2C* default_instance_;
};
// -------------------------------------------------------------------

class Msg_RoomOperate_C2S : public ::google::protobuf::Message {
 public:
  Msg_RoomOperate_C2S();
  virtual ~Msg_RoomOperate_C2S();

  Msg_RoomOperate_C2S(const Msg_RoomOperate_C2S& from);

  inline Msg_RoomOperate_C2S& operator=(const Msg_RoomOperate_C2S& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Msg_RoomOperate_C2S& default_instance();

  void Swap(Msg_RoomOperate_C2S* other);

  // implements Message ----------------------------------------------

  Msg_RoomOperate_C2S* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Msg_RoomOperate_C2S& from);
  void MergeFrom(const Msg_RoomOperate_C2S& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required fixed32 ID = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIDFieldNumber = 1;
  inline ::google::protobuf::uint32 id() const;
  inline void set_id(::google::protobuf::uint32 value);

  // required .RoomOperateType operateType = 2;
  inline bool has_operatetype() const;
  inline void clear_operatetype();
  static const int kOperateTypeFieldNumber = 2;
  inline ::RoomOperateType operatetype() const;
  inline void set_operatetype(::RoomOperateType value);

  // optional fixed32 roomID = 3;
  inline bool has_roomid() const;
  inline void clear_roomid();
  static const int kRoomIDFieldNumber = 3;
  inline ::google::protobuf::uint32 roomid() const;
  inline void set_roomid(::google::protobuf::uint32 value);

  // optional string roomName = 4;
  inline bool has_roomname() const;
  inline void clear_roomname();
  static const int kRoomNameFieldNumber = 4;
  inline const ::std::string& roomname() const;
  inline void set_roomname(const ::std::string& value);
  inline void set_roomname(const char* value);
  inline void set_roomname(const char* value, size_t size);
  inline ::std::string* mutable_roomname();
  inline ::std::string* release_roomname();
  inline void set_allocated_roomname(::std::string* roomname);

  // optional fixed32 roomUserNumber = 5;
  inline bool has_roomusernumber() const;
  inline void clear_roomusernumber();
  static const int kRoomUserNumberFieldNumber = 5;
  inline ::google::protobuf::uint32 roomusernumber() const;
  inline void set_roomusernumber(::google::protobuf::uint32 value);

  // optional .GamePattern roomPattern = 6;
  inline bool has_roompattern() const;
  inline void clear_roompattern();
  static const int kRoomPatternFieldNumber = 6;
  inline ::GamePattern roompattern() const;
  inline void set_roompattern(::GamePattern value);

  // optional string Map = 7;
  inline bool has_map() const;
  inline void clear_map();
  static const int kMapFieldNumber = 7;
  inline const ::std::string& map() const;
  inline void set_map(const ::std::string& value);
  inline void set_map(const char* value);
  inline void set_map(const char* value, size_t size);
  inline ::std::string* mutable_map();
  inline ::std::string* release_map();
  inline void set_allocated_map(::std::string* map);

  // @@protoc_insertion_point(class_scope:Msg_RoomOperate_C2S)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_operatetype();
  inline void clear_has_operatetype();
  inline void set_has_roomid();
  inline void clear_has_roomid();
  inline void set_has_roomname();
  inline void clear_has_roomname();
  inline void set_has_roomusernumber();
  inline void clear_has_roomusernumber();
  inline void set_has_roompattern();
  inline void clear_has_roompattern();
  inline void set_has_map();
  inline void clear_has_map();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 id_;
  int operatetype_;
  ::std::string* roomname_;
  ::google::protobuf::uint32 roomid_;
  ::google::protobuf::uint32 roomusernumber_;
  ::std::string* map_;
  int roompattern_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_Msg_2eproto();
  friend void protobuf_AssignDesc_Msg_2eproto();
  friend void protobuf_ShutdownFile_Msg_2eproto();

  void InitAsDefaultInstance();
  static Msg_RoomOperate_C2S* default_instance_;
};
// -------------------------------------------------------------------

class Msg_RoomOperate_S2C : public ::google::protobuf::Message {
 public:
  Msg_RoomOperate_S2C();
  virtual ~Msg_RoomOperate_S2C();

  Msg_RoomOperate_S2C(const Msg_RoomOperate_S2C& from);

  inline Msg_RoomOperate_S2C& operator=(const Msg_RoomOperate_S2C& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Msg_RoomOperate_S2C& default_instance();

  void Swap(Msg_RoomOperate_S2C* other);

  // implements Message ----------------------------------------------

  Msg_RoomOperate_S2C* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Msg_RoomOperate_S2C& from);
  void MergeFrom(const Msg_RoomOperate_S2C& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required fixed32 ID = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIDFieldNumber = 1;
  inline ::google::protobuf::uint32 id() const;
  inline void set_id(::google::protobuf::uint32 value);

  // required .RoomOperateType operateType = 2;
  inline bool has_operatetype() const;
  inline void clear_operatetype();
  static const int kOperateTypeFieldNumber = 2;
  inline ::RoomOperateType operatetype() const;
  inline void set_operatetype(::RoomOperateType value);

  // required fixed32 roomID = 3;
  inline bool has_roomid() const;
  inline void clear_roomid();
  static const int kRoomIDFieldNumber = 3;
  inline ::google::protobuf::uint32 roomid() const;
  inline void set_roomid(::google::protobuf::uint32 value);

  // required bool success = 4;
  inline bool has_success() const;
  inline void clear_success();
  static const int kSuccessFieldNumber = 4;
  inline bool success() const;
  inline void set_success(bool value);

  // optional string roomName = 5;
  inline bool has_roomname() const;
  inline void clear_roomname();
  static const int kRoomNameFieldNumber = 5;
  inline const ::std::string& roomname() const;
  inline void set_roomname(const ::std::string& value);
  inline void set_roomname(const char* value);
  inline void set_roomname(const char* value, size_t size);
  inline ::std::string* mutable_roomname();
  inline ::std::string* release_roomname();
  inline void set_allocated_roomname(::std::string* roomname);

  // optional fixed32 roomUserNumber = 6;
  inline bool has_roomusernumber() const;
  inline void clear_roomusernumber();
  static const int kRoomUserNumberFieldNumber = 6;
  inline ::google::protobuf::uint32 roomusernumber() const;
  inline void set_roomusernumber(::google::protobuf::uint32 value);

  // optional .GamePattern roomPattern = 7;
  inline bool has_roompattern() const;
  inline void clear_roompattern();
  static const int kRoomPatternFieldNumber = 7;
  inline ::GamePattern roompattern() const;
  inline void set_roompattern(::GamePattern value);

  // repeated .protoaccount players = 8;
  inline int players_size() const;
  inline void clear_players();
  static const int kPlayersFieldNumber = 8;
  inline const ::protoaccount& players(int index) const;
  inline ::protoaccount* mutable_players(int index);
  inline ::protoaccount* add_players();
  inline const ::google::protobuf::RepeatedPtrField< ::protoaccount >&
      players() const;
  inline ::google::protobuf::RepeatedPtrField< ::protoaccount >*
      mutable_players();

  // optional string Map = 9;
  inline bool has_map() const;
  inline void clear_map();
  static const int kMapFieldNumber = 9;
  inline const ::std::string& map() const;
  inline void set_map(const ::std::string& value);
  inline void set_map(const char* value);
  inline void set_map(const char* value, size_t size);
  inline ::std::string* mutable_map();
  inline ::std::string* release_map();
  inline void set_allocated_map(::std::string* map);

  // @@protoc_insertion_point(class_scope:Msg_RoomOperate_S2C)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_operatetype();
  inline void clear_has_operatetype();
  inline void set_has_roomid();
  inline void clear_has_roomid();
  inline void set_has_success();
  inline void clear_has_success();
  inline void set_has_roomname();
  inline void clear_has_roomname();
  inline void set_has_roomusernumber();
  inline void clear_has_roomusernumber();
  inline void set_has_roompattern();
  inline void clear_has_roompattern();
  inline void set_has_map();
  inline void clear_has_map();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 id_;
  int operatetype_;
  ::google::protobuf::uint32 roomid_;
  bool success_;
  ::std::string* roomname_;
  ::google::protobuf::uint32 roomusernumber_;
  int roompattern_;
  ::google::protobuf::RepeatedPtrField< ::protoaccount > players_;
  ::std::string* map_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];

  friend void  protobuf_AddDesc_Msg_2eproto();
  friend void protobuf_AssignDesc_Msg_2eproto();
  friend void protobuf_ShutdownFile_Msg_2eproto();

  void InitAsDefaultInstance();
  static Msg_RoomOperate_S2C* default_instance_;
};
// -------------------------------------------------------------------

class Msg_StartBattle_C2S : public ::google::protobuf::Message {
 public:
  Msg_StartBattle_C2S();
  virtual ~Msg_StartBattle_C2S();

  Msg_StartBattle_C2S(const Msg_StartBattle_C2S& from);

  inline Msg_StartBattle_C2S& operator=(const Msg_StartBattle_C2S& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Msg_StartBattle_C2S& default_instance();

  void Swap(Msg_StartBattle_C2S* other);

  // implements Message ----------------------------------------------

  Msg_StartBattle_C2S* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Msg_StartBattle_C2S& from);
  void MergeFrom(const Msg_StartBattle_C2S& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string szName = 1;
  inline bool has_szname() const;
  inline void clear_szname();
  static const int kSzNameFieldNumber = 1;
  inline const ::std::string& szname() const;
  inline void set_szname(const ::std::string& value);
  inline void set_szname(const char* value);
  inline void set_szname(const char* value, size_t size);
  inline ::std::string* mutable_szname();
  inline ::std::string* release_szname();
  inline void set_allocated_szname(::std::string* szname);

  // required fixed32 ID = 2;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIDFieldNumber = 2;
  inline ::google::protobuf::uint32 id() const;
  inline void set_id(::google::protobuf::uint32 value);

  // required fixed32 ID2 = 3;
  inline bool has_id2() const;
  inline void clear_id2();
  static const int kID2FieldNumber = 3;
  inline ::google::protobuf::uint32 id2() const;
  inline void set_id2(::google::protobuf::uint32 value);

  // required fixed32 roomID = 4;
  inline bool has_roomid() const;
  inline void clear_roomid();
  static const int kRoomIDFieldNumber = 4;
  inline ::google::protobuf::uint32 roomid() const;
  inline void set_roomid(::google::protobuf::uint32 value);

  // required .GamePattern pattern = 5;
  inline bool has_pattern() const;
  inline void clear_pattern();
  static const int kPatternFieldNumber = 5;
  inline ::GamePattern pattern() const;
  inline void set_pattern(::GamePattern value);

  // @@protoc_insertion_point(class_scope:Msg_StartBattle_C2S)
 private:
  inline void set_has_szname();
  inline void clear_has_szname();
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_id2();
  inline void clear_has_id2();
  inline void set_has_roomid();
  inline void clear_has_roomid();
  inline void set_has_pattern();
  inline void clear_has_pattern();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* szname_;
  ::google::protobuf::uint32 id_;
  ::google::protobuf::uint32 id2_;
  ::google::protobuf::uint32 roomid_;
  int pattern_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_Msg_2eproto();
  friend void protobuf_AssignDesc_Msg_2eproto();
  friend void protobuf_ShutdownFile_Msg_2eproto();

  void InitAsDefaultInstance();
  static Msg_StartBattle_C2S* default_instance_;
};
// -------------------------------------------------------------------

class Msg_StartBattle_S2C : public ::google::protobuf::Message {
 public:
  Msg_StartBattle_S2C();
  virtual ~Msg_StartBattle_S2C();

  Msg_StartBattle_S2C(const Msg_StartBattle_S2C& from);

  inline Msg_StartBattle_S2C& operator=(const Msg_StartBattle_S2C& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Msg_StartBattle_S2C& default_instance();

  void Swap(Msg_StartBattle_S2C* other);

  // implements Message ----------------------------------------------

  Msg_StartBattle_S2C* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Msg_StartBattle_S2C& from);
  void MergeFrom(const Msg_StartBattle_S2C& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string szName = 1;
  inline bool has_szname() const;
  inline void clear_szname();
  static const int kSzNameFieldNumber = 1;
  inline const ::std::string& szname() const;
  inline void set_szname(const ::std::string& value);
  inline void set_szname(const char* value);
  inline void set_szname(const char* value, size_t size);
  inline ::std::string* mutable_szname();
  inline ::std::string* release_szname();
  inline void set_allocated_szname(::std::string* szname);

  // required fixed32 ID = 2;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIDFieldNumber = 2;
  inline ::google::protobuf::uint32 id() const;
  inline void set_id(::google::protobuf::uint32 value);

  // required fixed32 ID2 = 3;
  inline bool has_id2() const;
  inline void clear_id2();
  static const int kID2FieldNumber = 3;
  inline ::google::protobuf::uint32 id2() const;
  inline void set_id2(::google::protobuf::uint32 value);

  // required fixed32 roomID = 4;
  inline bool has_roomid() const;
  inline void clear_roomid();
  static const int kRoomIDFieldNumber = 4;
  inline ::google::protobuf::uint32 roomid() const;
  inline void set_roomid(::google::protobuf::uint32 value);

  // required .GamePattern pattern = 5;
  inline bool has_pattern() const;
  inline void clear_pattern();
  static const int kPatternFieldNumber = 5;
  inline ::GamePattern pattern() const;
  inline void set_pattern(::GamePattern value);

  // required fixed32 BattleId = 6;
  inline bool has_battleid() const;
  inline void clear_battleid();
  static const int kBattleIdFieldNumber = 6;
  inline ::google::protobuf::uint32 battleid() const;
  inline void set_battleid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Msg_StartBattle_S2C)
 private:
  inline void set_has_szname();
  inline void clear_has_szname();
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_id2();
  inline void clear_has_id2();
  inline void set_has_roomid();
  inline void clear_has_roomid();
  inline void set_has_pattern();
  inline void clear_has_pattern();
  inline void set_has_battleid();
  inline void clear_has_battleid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* szname_;
  ::google::protobuf::uint32 id_;
  ::google::protobuf::uint32 id2_;
  ::google::protobuf::uint32 roomid_;
  int pattern_;
  ::google::protobuf::uint32 battleid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_Msg_2eproto();
  friend void protobuf_AssignDesc_Msg_2eproto();
  friend void protobuf_ShutdownFile_Msg_2eproto();

  void InitAsDefaultInstance();
  static Msg_StartBattle_S2C* default_instance_;
};
// -------------------------------------------------------------------

class Msg_OriginHandCards_S2C : public ::google::protobuf::Message {
 public:
  Msg_OriginHandCards_S2C();
  virtual ~Msg_OriginHandCards_S2C();

  Msg_OriginHandCards_S2C(const Msg_OriginHandCards_S2C& from);

  inline Msg_OriginHandCards_S2C& operator=(const Msg_OriginHandCards_S2C& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Msg_OriginHandCards_S2C& default_instance();

  void Swap(Msg_OriginHandCards_S2C* other);

  // implements Message ----------------------------------------------

  Msg_OriginHandCards_S2C* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Msg_OriginHandCards_S2C& from);
  void MergeFrom(const Msg_OriginHandCards_S2C& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required fixed32 playerid = 1;
  inline bool has_playerid() const;
  inline void clear_playerid();
  static const int kPlayeridFieldNumber = 1;
  inline ::google::protobuf::uint32 playerid() const;
  inline void set_playerid(::google::protobuf::uint32 value);

  // repeated .protocard cards = 2;
  inline int cards_size() const;
  inline void clear_cards();
  static const int kCardsFieldNumber = 2;
  inline const ::protocard& cards(int index) const;
  inline ::protocard* mutable_cards(int index);
  inline ::protocard* add_cards();
  inline const ::google::protobuf::RepeatedPtrField< ::protocard >&
      cards() const;
  inline ::google::protobuf::RepeatedPtrField< ::protocard >*
      mutable_cards();

  // @@protoc_insertion_point(class_scope:Msg_OriginHandCards_S2C)
 private:
  inline void set_has_playerid();
  inline void clear_has_playerid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::protocard > cards_;
  ::google::protobuf::uint32 playerid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_Msg_2eproto();
  friend void protobuf_AssignDesc_Msg_2eproto();
  friend void protobuf_ShutdownFile_Msg_2eproto();

  void InitAsDefaultInstance();
  static Msg_OriginHandCards_S2C* default_instance_;
};
// -------------------------------------------------------------------

class Msg_GameUpdate_C2S : public ::google::protobuf::Message {
 public:
  Msg_GameUpdate_C2S();
  virtual ~Msg_GameUpdate_C2S();

  Msg_GameUpdate_C2S(const Msg_GameUpdate_C2S& from);

  inline Msg_GameUpdate_C2S& operator=(const Msg_GameUpdate_C2S& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Msg_GameUpdate_C2S& default_instance();

  void Swap(Msg_GameUpdate_C2S* other);

  // implements Message ----------------------------------------------

  Msg_GameUpdate_C2S* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Msg_GameUpdate_C2S& from);
  void MergeFrom(const Msg_GameUpdate_C2S& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required fixed32 BattleId = 1;
  inline bool has_battleid() const;
  inline void clear_battleid();
  static const int kBattleIdFieldNumber = 1;
  inline ::google::protobuf::uint32 battleid() const;
  inline void set_battleid(::google::protobuf::uint32 value);

  // required fixed32 Round = 2;
  inline bool has_round() const;
  inline void clear_round();
  static const int kRoundFieldNumber = 2;
  inline ::google::protobuf::uint32 round() const;
  inline void set_round(::google::protobuf::uint32 value);

  // required .protocard useCard = 3;
  inline bool has_usecard() const;
  inline void clear_usecard();
  static const int kUseCardFieldNumber = 3;
  inline const ::protocard& usecard() const;
  inline ::protocard* mutable_usecard();
  inline ::protocard* release_usecard();
  inline void set_allocated_usecard(::protocard* usecard);

  // required fixed32 playerID = 4;
  inline bool has_playerid() const;
  inline void clear_playerid();
  static const int kPlayerIDFieldNumber = 4;
  inline ::google::protobuf::uint32 playerid() const;
  inline void set_playerid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Msg_GameUpdate_C2S)
 private:
  inline void set_has_battleid();
  inline void clear_has_battleid();
  inline void set_has_round();
  inline void clear_has_round();
  inline void set_has_usecard();
  inline void clear_has_usecard();
  inline void set_has_playerid();
  inline void clear_has_playerid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 battleid_;
  ::google::protobuf::uint32 round_;
  ::protocard* usecard_;
  ::google::protobuf::uint32 playerid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_Msg_2eproto();
  friend void protobuf_AssignDesc_Msg_2eproto();
  friend void protobuf_ShutdownFile_Msg_2eproto();

  void InitAsDefaultInstance();
  static Msg_GameUpdate_C2S* default_instance_;
};
// -------------------------------------------------------------------

class Msg_GameUpdate_S2C : public ::google::protobuf::Message {
 public:
  Msg_GameUpdate_S2C();
  virtual ~Msg_GameUpdate_S2C();

  Msg_GameUpdate_S2C(const Msg_GameUpdate_S2C& from);

  inline Msg_GameUpdate_S2C& operator=(const Msg_GameUpdate_S2C& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Msg_GameUpdate_S2C& default_instance();

  void Swap(Msg_GameUpdate_S2C* other);

  // implements Message ----------------------------------------------

  Msg_GameUpdate_S2C* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Msg_GameUpdate_S2C& from);
  void MergeFrom(const Msg_GameUpdate_S2C& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required fixed32 BattleId = 1;
  inline bool has_battleid() const;
  inline void clear_battleid();
  static const int kBattleIdFieldNumber = 1;
  inline ::google::protobuf::uint32 battleid() const;
  inline void set_battleid(::google::protobuf::uint32 value);

  // required fixed32 player1_hp = 2;
  inline bool has_player1_hp() const;
  inline void clear_player1_hp();
  static const int kPlayer1HpFieldNumber = 2;
  inline ::google::protobuf::uint32 player1_hp() const;
  inline void set_player1_hp(::google::protobuf::uint32 value);

  // required fixed32 player2_hp = 3;
  inline bool has_player2_hp() const;
  inline void clear_player2_hp();
  static const int kPlayer2HpFieldNumber = 3;
  inline ::google::protobuf::uint32 player2_hp() const;
  inline void set_player2_hp(::google::protobuf::uint32 value);

  // required .protocard player1_usecard = 4;
  inline bool has_player1_usecard() const;
  inline void clear_player1_usecard();
  static const int kPlayer1UsecardFieldNumber = 4;
  inline const ::protocard& player1_usecard() const;
  inline ::protocard* mutable_player1_usecard();
  inline ::protocard* release_player1_usecard();
  inline void set_allocated_player1_usecard(::protocard* player1_usecard);

  // required .protocard player2_usecard = 5;
  inline bool has_player2_usecard() const;
  inline void clear_player2_usecard();
  static const int kPlayer2UsecardFieldNumber = 5;
  inline const ::protocard& player2_usecard() const;
  inline ::protocard* mutable_player2_usecard();
  inline ::protocard* release_player2_usecard();
  inline void set_allocated_player2_usecard(::protocard* player2_usecard);

  // optional .protocard player1_gotCard = 6;
  inline bool has_player1_gotcard() const;
  inline void clear_player1_gotcard();
  static const int kPlayer1GotCardFieldNumber = 6;
  inline const ::protocard& player1_gotcard() const;
  inline ::protocard* mutable_player1_gotcard();
  inline ::protocard* release_player1_gotcard();
  inline void set_allocated_player1_gotcard(::protocard* player1_gotcard);

  // optional .protocard player2_gotCard = 7;
  inline bool has_player2_gotcard() const;
  inline void clear_player2_gotcard();
  static const int kPlayer2GotCardFieldNumber = 7;
  inline const ::protocard& player2_gotcard() const;
  inline ::protocard* mutable_player2_gotcard();
  inline ::protocard* release_player2_gotcard();
  inline void set_allocated_player2_gotcard(::protocard* player2_gotcard);

  // @@protoc_insertion_point(class_scope:Msg_GameUpdate_S2C)
 private:
  inline void set_has_battleid();
  inline void clear_has_battleid();
  inline void set_has_player1_hp();
  inline void clear_has_player1_hp();
  inline void set_has_player2_hp();
  inline void clear_has_player2_hp();
  inline void set_has_player1_usecard();
  inline void clear_has_player1_usecard();
  inline void set_has_player2_usecard();
  inline void clear_has_player2_usecard();
  inline void set_has_player1_gotcard();
  inline void clear_has_player1_gotcard();
  inline void set_has_player2_gotcard();
  inline void clear_has_player2_gotcard();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 battleid_;
  ::google::protobuf::uint32 player1_hp_;
  ::protocard* player1_usecard_;
  ::protocard* player2_usecard_;
  ::protocard* player1_gotcard_;
  ::protocard* player2_gotcard_;
  ::google::protobuf::uint32 player2_hp_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_Msg_2eproto();
  friend void protobuf_AssignDesc_Msg_2eproto();
  friend void protobuf_ShutdownFile_Msg_2eproto();

  void InitAsDefaultInstance();
  static Msg_GameUpdate_S2C* default_instance_;
};
// -------------------------------------------------------------------

class Msg_Surrender_C2S : public ::google::protobuf::Message {
 public:
  Msg_Surrender_C2S();
  virtual ~Msg_Surrender_C2S();

  Msg_Surrender_C2S(const Msg_Surrender_C2S& from);

  inline Msg_Surrender_C2S& operator=(const Msg_Surrender_C2S& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Msg_Surrender_C2S& default_instance();

  void Swap(Msg_Surrender_C2S* other);

  // implements Message ----------------------------------------------

  Msg_Surrender_C2S* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Msg_Surrender_C2S& from);
  void MergeFrom(const Msg_Surrender_C2S& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required fixed32 ID = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIDFieldNumber = 1;
  inline ::google::protobuf::uint32 id() const;
  inline void set_id(::google::protobuf::uint32 value);

  // required fixed32 BattleId = 2;
  inline bool has_battleid() const;
  inline void clear_battleid();
  static const int kBattleIdFieldNumber = 2;
  inline ::google::protobuf::uint32 battleid() const;
  inline void set_battleid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Msg_Surrender_C2S)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_battleid();
  inline void clear_has_battleid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 id_;
  ::google::protobuf::uint32 battleid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_Msg_2eproto();
  friend void protobuf_AssignDesc_Msg_2eproto();
  friend void protobuf_ShutdownFile_Msg_2eproto();

  void InitAsDefaultInstance();
  static Msg_Surrender_C2S* default_instance_;
};
// -------------------------------------------------------------------

class Msg_Gameover_S2C : public ::google::protobuf::Message {
 public:
  Msg_Gameover_S2C();
  virtual ~Msg_Gameover_S2C();

  Msg_Gameover_S2C(const Msg_Gameover_S2C& from);

  inline Msg_Gameover_S2C& operator=(const Msg_Gameover_S2C& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Msg_Gameover_S2C& default_instance();

  void Swap(Msg_Gameover_S2C* other);

  // implements Message ----------------------------------------------

  Msg_Gameover_S2C* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Msg_Gameover_S2C& from);
  void MergeFrom(const Msg_Gameover_S2C& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required fixed32 BattleId = 1;
  inline bool has_battleid() const;
  inline void clear_battleid();
  static const int kBattleIdFieldNumber = 1;
  inline ::google::protobuf::uint32 battleid() const;
  inline void set_battleid(::google::protobuf::uint32 value);

  // required fixed32 player1_id = 2;
  inline bool has_player1_id() const;
  inline void clear_player1_id();
  static const int kPlayer1IdFieldNumber = 2;
  inline ::google::protobuf::uint32 player1_id() const;
  inline void set_player1_id(::google::protobuf::uint32 value);

  // required fixed32 player2_id = 3;
  inline bool has_player2_id() const;
  inline void clear_player2_id();
  static const int kPlayer2IdFieldNumber = 3;
  inline ::google::protobuf::uint32 player2_id() const;
  inline void set_player2_id(::google::protobuf::uint32 value);

  // required bool player1_victory = 4;
  inline bool has_player1_victory() const;
  inline void clear_player1_victory();
  static const int kPlayer1VictoryFieldNumber = 4;
  inline bool player1_victory() const;
  inline void set_player1_victory(bool value);

  // required bool player2_victory = 5;
  inline bool has_player2_victory() const;
  inline void clear_player2_victory();
  static const int kPlayer2VictoryFieldNumber = 5;
  inline bool player2_victory() const;
  inline void set_player2_victory(bool value);

  // @@protoc_insertion_point(class_scope:Msg_Gameover_S2C)
 private:
  inline void set_has_battleid();
  inline void clear_has_battleid();
  inline void set_has_player1_id();
  inline void clear_has_player1_id();
  inline void set_has_player2_id();
  inline void clear_has_player2_id();
  inline void set_has_player1_victory();
  inline void clear_has_player1_victory();
  inline void set_has_player2_victory();
  inline void clear_has_player2_victory();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 battleid_;
  ::google::protobuf::uint32 player1_id_;
  ::google::protobuf::uint32 player2_id_;
  bool player1_victory_;
  bool player2_victory_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_Msg_2eproto();
  friend void protobuf_AssignDesc_Msg_2eproto();
  friend void protobuf_ShutdownFile_Msg_2eproto();

  void InitAsDefaultInstance();
  static Msg_Gameover_S2C* default_instance_;
};
// -------------------------------------------------------------------

class Msg_RoomList_S2C : public ::google::protobuf::Message {
 public:
  Msg_RoomList_S2C();
  virtual ~Msg_RoomList_S2C();

  Msg_RoomList_S2C(const Msg_RoomList_S2C& from);

  inline Msg_RoomList_S2C& operator=(const Msg_RoomList_S2C& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Msg_RoomList_S2C& default_instance();

  void Swap(Msg_RoomList_S2C* other);

  // implements Message ----------------------------------------------

  Msg_RoomList_S2C* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Msg_RoomList_S2C& from);
  void MergeFrom(const Msg_RoomList_S2C& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .protoRoom rooms = 1;
  inline int rooms_size() const;
  inline void clear_rooms();
  static const int kRoomsFieldNumber = 1;
  inline const ::protoRoom& rooms(int index) const;
  inline ::protoRoom* mutable_rooms(int index);
  inline ::protoRoom* add_rooms();
  inline const ::google::protobuf::RepeatedPtrField< ::protoRoom >&
      rooms() const;
  inline ::google::protobuf::RepeatedPtrField< ::protoRoom >*
      mutable_rooms();

  // @@protoc_insertion_point(class_scope:Msg_RoomList_S2C)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::protoRoom > rooms_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_Msg_2eproto();
  friend void protobuf_AssignDesc_Msg_2eproto();
  friend void protobuf_ShutdownFile_Msg_2eproto();

  void InitAsDefaultInstance();
  static Msg_RoomList_S2C* default_instance_;
};
// -------------------------------------------------------------------

class Msg_AccountMsg_C2S : public ::google::protobuf::Message {
 public:
  Msg_AccountMsg_C2S();
  virtual ~Msg_AccountMsg_C2S();

  Msg_AccountMsg_C2S(const Msg_AccountMsg_C2S& from);

  inline Msg_AccountMsg_C2S& operator=(const Msg_AccountMsg_C2S& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Msg_AccountMsg_C2S& default_instance();

  void Swap(Msg_AccountMsg_C2S* other);

  // implements Message ----------------------------------------------

  Msg_AccountMsg_C2S* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Msg_AccountMsg_C2S& from);
  void MergeFrom(const Msg_AccountMsg_C2S& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required fixed32 requestid = 1;
  inline bool has_requestid() const;
  inline void clear_requestid();
  static const int kRequestidFieldNumber = 1;
  inline ::google::protobuf::uint32 requestid() const;
  inline void set_requestid(::google::protobuf::uint32 value);

  // required bool get = 2;
  inline bool has_get() const;
  inline void clear_get();
  static const int kGetFieldNumber = 2;
  inline bool get() const;
  inline void set_get(bool value);

  // optional string headImg = 3;
  inline bool has_headimg() const;
  inline void clear_headimg();
  static const int kHeadImgFieldNumber = 3;
  inline const ::std::string& headimg() const;
  inline void set_headimg(const ::std::string& value);
  inline void set_headimg(const char* value);
  inline void set_headimg(const char* value, size_t size);
  inline ::std::string* mutable_headimg();
  inline ::std::string* release_headimg();
  inline void set_allocated_headimg(::std::string* headimg);

  // @@protoc_insertion_point(class_scope:Msg_AccountMsg_C2S)
 private:
  inline void set_has_requestid();
  inline void clear_has_requestid();
  inline void set_has_get();
  inline void clear_has_get();
  inline void set_has_headimg();
  inline void clear_has_headimg();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 requestid_;
  bool get_;
  ::std::string* headimg_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_Msg_2eproto();
  friend void protobuf_AssignDesc_Msg_2eproto();
  friend void protobuf_ShutdownFile_Msg_2eproto();

  void InitAsDefaultInstance();
  static Msg_AccountMsg_C2S* default_instance_;
};
// -------------------------------------------------------------------

class Msg_AccountMsg_S2C : public ::google::protobuf::Message {
 public:
  Msg_AccountMsg_S2C();
  virtual ~Msg_AccountMsg_S2C();

  Msg_AccountMsg_S2C(const Msg_AccountMsg_S2C& from);

  inline Msg_AccountMsg_S2C& operator=(const Msg_AccountMsg_S2C& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Msg_AccountMsg_S2C& default_instance();

  void Swap(Msg_AccountMsg_S2C* other);

  // implements Message ----------------------------------------------

  Msg_AccountMsg_S2C* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Msg_AccountMsg_S2C& from);
  void MergeFrom(const Msg_AccountMsg_S2C& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .protoaccount account = 1;
  inline bool has_account() const;
  inline void clear_account();
  static const int kAccountFieldNumber = 1;
  inline const ::protoaccount& account() const;
  inline ::protoaccount* mutable_account();
  inline ::protoaccount* release_account();
  inline void set_allocated_account(::protoaccount* account);

  // @@protoc_insertion_point(class_scope:Msg_AccountMsg_S2C)
 private:
  inline void set_has_account();
  inline void clear_has_account();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::protoaccount* account_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_Msg_2eproto();
  friend void protobuf_AssignDesc_Msg_2eproto();
  friend void protobuf_ShutdownFile_Msg_2eproto();

  void InitAsDefaultInstance();
  static Msg_AccountMsg_S2C* default_instance_;
};
// -------------------------------------------------------------------

class protoaccount : public ::google::protobuf::Message {
 public:
  protoaccount();
  virtual ~protoaccount();

  protoaccount(const protoaccount& from);

  inline protoaccount& operator=(const protoaccount& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const protoaccount& default_instance();

  void Swap(protoaccount* other);

  // implements Message ----------------------------------------------

  protoaccount* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const protoaccount& from);
  void MergeFrom(const protoaccount& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional fixed32 Score = 2;
  inline bool has_score() const;
  inline void clear_score();
  static const int kScoreFieldNumber = 2;
  inline ::google::protobuf::uint32 score() const;
  inline void set_score(::google::protobuf::uint32 value);

  // optional fixed32 BattleNums = 3;
  inline bool has_battlenums() const;
  inline void clear_battlenums();
  static const int kBattleNumsFieldNumber = 3;
  inline ::google::protobuf::uint32 battlenums() const;
  inline void set_battlenums(::google::protobuf::uint32 value);

  // optional fixed32 StandardBattles = 4;
  inline bool has_standardbattles() const;
  inline void clear_standardbattles();
  static const int kStandardBattlesFieldNumber = 4;
  inline ::google::protobuf::uint32 standardbattles() const;
  inline void set_standardbattles(::google::protobuf::uint32 value);

  // optional fixed32 RankBattles = 5;
  inline bool has_rankbattles() const;
  inline void clear_rankbattles();
  static const int kRankBattlesFieldNumber = 5;
  inline ::google::protobuf::uint32 rankbattles() const;
  inline void set_rankbattles(::google::protobuf::uint32 value);

  // optional fixed32 BattleWins = 6;
  inline bool has_battlewins() const;
  inline void clear_battlewins();
  static const int kBattleWinsFieldNumber = 6;
  inline ::google::protobuf::uint32 battlewins() const;
  inline void set_battlewins(::google::protobuf::uint32 value);

  // optional fixed32 StandardWins = 7;
  inline bool has_standardwins() const;
  inline void clear_standardwins();
  static const int kStandardWinsFieldNumber = 7;
  inline ::google::protobuf::uint32 standardwins() const;
  inline void set_standardwins(::google::protobuf::uint32 value);

  // optional fixed32 RankWins = 8;
  inline bool has_rankwins() const;
  inline void clear_rankwins();
  static const int kRankWinsFieldNumber = 8;
  inline ::google::protobuf::uint32 rankwins() const;
  inline void set_rankwins(::google::protobuf::uint32 value);

  // optional string title = 9;
  inline bool has_title() const;
  inline void clear_title();
  static const int kTitleFieldNumber = 9;
  inline const ::std::string& title() const;
  inline void set_title(const ::std::string& value);
  inline void set_title(const char* value);
  inline void set_title(const char* value, size_t size);
  inline ::std::string* mutable_title();
  inline ::std::string* release_title();
  inline void set_allocated_title(::std::string* title);

  // optional string HeadImg = 10;
  inline bool has_headimg() const;
  inline void clear_headimg();
  static const int kHeadImgFieldNumber = 10;
  inline const ::std::string& headimg() const;
  inline void set_headimg(const ::std::string& value);
  inline void set_headimg(const char* value);
  inline void set_headimg(const char* value, size_t size);
  inline ::std::string* mutable_headimg();
  inline ::std::string* release_headimg();
  inline void set_allocated_headimg(::std::string* headimg);

  // @@protoc_insertion_point(class_scope:protoaccount)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_score();
  inline void clear_has_score();
  inline void set_has_battlenums();
  inline void clear_has_battlenums();
  inline void set_has_standardbattles();
  inline void clear_has_standardbattles();
  inline void set_has_rankbattles();
  inline void clear_has_rankbattles();
  inline void set_has_battlewins();
  inline void clear_has_battlewins();
  inline void set_has_standardwins();
  inline void clear_has_standardwins();
  inline void set_has_rankwins();
  inline void clear_has_rankwins();
  inline void set_has_title();
  inline void clear_has_title();
  inline void set_has_headimg();
  inline void clear_has_headimg();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  ::google::protobuf::uint32 score_;
  ::google::protobuf::uint32 battlenums_;
  ::google::protobuf::uint32 standardbattles_;
  ::google::protobuf::uint32 rankbattles_;
  ::google::protobuf::uint32 battlewins_;
  ::google::protobuf::uint32 standardwins_;
  ::std::string* title_;
  ::std::string* headimg_;
  ::google::protobuf::uint32 rankwins_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(10 + 31) / 32];

  friend void  protobuf_AddDesc_Msg_2eproto();
  friend void protobuf_AssignDesc_Msg_2eproto();
  friend void protobuf_ShutdownFile_Msg_2eproto();

  void InitAsDefaultInstance();
  static protoaccount* default_instance_;
};
// -------------------------------------------------------------------

class protocard : public ::google::protobuf::Message {
 public:
  protocard();
  virtual ~protocard();

  protocard(const protocard& from);

  inline protocard& operator=(const protocard& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const protocard& default_instance();

  void Swap(protocard* other);

  // implements Message ----------------------------------------------

  protocard* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const protocard& from);
  void MergeFrom(const protocard& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required fixed32 card_id = 1;
  inline bool has_card_id() const;
  inline void clear_card_id();
  static const int kCardIdFieldNumber = 1;
  inline ::google::protobuf::uint32 card_id() const;
  inline void set_card_id(::google::protobuf::uint32 value);

  // required .CardAttribute card_attribute = 2;
  inline bool has_card_attribute() const;
  inline void clear_card_attribute();
  static const int kCardAttributeFieldNumber = 2;
  inline ::CardAttribute card_attribute() const;
  inline void set_card_attribute(::CardAttribute value);

  // required fixed32 card_type = 3;
  inline bool has_card_type() const;
  inline void clear_card_type();
  static const int kCardTypeFieldNumber = 3;
  inline ::google::protobuf::uint32 card_type() const;
  inline void set_card_type(::google::protobuf::uint32 value);

  // required fixed32 card_value = 4;
  inline bool has_card_value() const;
  inline void clear_card_value();
  static const int kCardValueFieldNumber = 4;
  inline ::google::protobuf::uint32 card_value() const;
  inline void set_card_value(::google::protobuf::uint32 value);

  // optional string card_image = 5;
  inline bool has_card_image() const;
  inline void clear_card_image();
  static const int kCardImageFieldNumber = 5;
  inline const ::std::string& card_image() const;
  inline void set_card_image(const ::std::string& value);
  inline void set_card_image(const char* value);
  inline void set_card_image(const char* value, size_t size);
  inline ::std::string* mutable_card_image();
  inline ::std::string* release_card_image();
  inline void set_allocated_card_image(::std::string* card_image);

  // optional fixed32 imgID = 6;
  inline bool has_imgid() const;
  inline void clear_imgid();
  static const int kImgIDFieldNumber = 6;
  inline ::google::protobuf::uint32 imgid() const;
  inline void set_imgid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:protocard)
 private:
  inline void set_has_card_id();
  inline void clear_has_card_id();
  inline void set_has_card_attribute();
  inline void clear_has_card_attribute();
  inline void set_has_card_type();
  inline void clear_has_card_type();
  inline void set_has_card_value();
  inline void clear_has_card_value();
  inline void set_has_card_image();
  inline void clear_has_card_image();
  inline void set_has_imgid();
  inline void clear_has_imgid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 card_id_;
  int card_attribute_;
  ::google::protobuf::uint32 card_type_;
  ::google::protobuf::uint32 card_value_;
  ::std::string* card_image_;
  ::google::protobuf::uint32 imgid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_Msg_2eproto();
  friend void protobuf_AssignDesc_Msg_2eproto();
  friend void protobuf_ShutdownFile_Msg_2eproto();

  void InitAsDefaultInstance();
  static protocard* default_instance_;
};
// -------------------------------------------------------------------

class protoRoom : public ::google::protobuf::Message {
 public:
  protoRoom();
  virtual ~protoRoom();

  protoRoom(const protoRoom& from);

  inline protoRoom& operator=(const protoRoom& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const protoRoom& default_instance();

  void Swap(protoRoom* other);

  // implements Message ----------------------------------------------

  protoRoom* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const protoRoom& from);
  void MergeFrom(const protoRoom& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required fixed32 room_id = 1;
  inline bool has_room_id() const;
  inline void clear_room_id();
  static const int kRoomIdFieldNumber = 1;
  inline ::google::protobuf::uint32 room_id() const;
  inline void set_room_id(::google::protobuf::uint32 value);

  // required string room_name = 2;
  inline bool has_room_name() const;
  inline void clear_room_name();
  static const int kRoomNameFieldNumber = 2;
  inline const ::std::string& room_name() const;
  inline void set_room_name(const ::std::string& value);
  inline void set_room_name(const char* value);
  inline void set_room_name(const char* value, size_t size);
  inline ::std::string* mutable_room_name();
  inline ::std::string* release_room_name();
  inline void set_allocated_room_name(::std::string* room_name);

  // required fixed32 room_users = 3;
  inline bool has_room_users() const;
  inline void clear_room_users();
  static const int kRoomUsersFieldNumber = 3;
  inline ::google::protobuf::uint32 room_users() const;
  inline void set_room_users(::google::protobuf::uint32 value);

  // required .GamePattern roompattern = 4;
  inline bool has_roompattern() const;
  inline void clear_roompattern();
  static const int kRoompatternFieldNumber = 4;
  inline ::GamePattern roompattern() const;
  inline void set_roompattern(::GamePattern value);

  // optional string map = 5;
  inline bool has_map() const;
  inline void clear_map();
  static const int kMapFieldNumber = 5;
  inline const ::std::string& map() const;
  inline void set_map(const ::std::string& value);
  inline void set_map(const char* value);
  inline void set_map(const char* value, size_t size);
  inline ::std::string* mutable_map();
  inline ::std::string* release_map();
  inline void set_allocated_map(::std::string* map);

  // @@protoc_insertion_point(class_scope:protoRoom)
 private:
  inline void set_has_room_id();
  inline void clear_has_room_id();
  inline void set_has_room_name();
  inline void clear_has_room_name();
  inline void set_has_room_users();
  inline void clear_has_room_users();
  inline void set_has_roompattern();
  inline void clear_has_roompattern();
  inline void set_has_map();
  inline void clear_has_map();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* room_name_;
  ::google::protobuf::uint32 room_id_;
  ::google::protobuf::uint32 room_users_;
  ::std::string* map_;
  int roompattern_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_Msg_2eproto();
  friend void protobuf_AssignDesc_Msg_2eproto();
  friend void protobuf_ShutdownFile_Msg_2eproto();

  void InitAsDefaultInstance();
  static protoRoom* default_instance_;
};
// ===================================================================


// ===================================================================

// Msg_Login_C2S

// required fixed32 conMethod = 1;
inline bool Msg_Login_C2S::has_conmethod() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Msg_Login_C2S::set_has_conmethod() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Msg_Login_C2S::clear_has_conmethod() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Msg_Login_C2S::clear_conmethod() {
  conmethod_ = 0u;
  clear_has_conmethod();
}
inline ::google::protobuf::uint32 Msg_Login_C2S::conmethod() const {
  return conmethod_;
}
inline void Msg_Login_C2S::set_conmethod(::google::protobuf::uint32 value) {
  set_has_conmethod();
  conmethod_ = value;
}

// required string szName = 2;
inline bool Msg_Login_C2S::has_szname() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Msg_Login_C2S::set_has_szname() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Msg_Login_C2S::clear_has_szname() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Msg_Login_C2S::clear_szname() {
  if (szname_ != &::google::protobuf::internal::kEmptyString) {
    szname_->clear();
  }
  clear_has_szname();
}
inline const ::std::string& Msg_Login_C2S::szname() const {
  return *szname_;
}
inline void Msg_Login_C2S::set_szname(const ::std::string& value) {
  set_has_szname();
  if (szname_ == &::google::protobuf::internal::kEmptyString) {
    szname_ = new ::std::string;
  }
  szname_->assign(value);
}
inline void Msg_Login_C2S::set_szname(const char* value) {
  set_has_szname();
  if (szname_ == &::google::protobuf::internal::kEmptyString) {
    szname_ = new ::std::string;
  }
  szname_->assign(value);
}
inline void Msg_Login_C2S::set_szname(const char* value, size_t size) {
  set_has_szname();
  if (szname_ == &::google::protobuf::internal::kEmptyString) {
    szname_ = new ::std::string;
  }
  szname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Msg_Login_C2S::mutable_szname() {
  set_has_szname();
  if (szname_ == &::google::protobuf::internal::kEmptyString) {
    szname_ = new ::std::string;
  }
  return szname_;
}
inline ::std::string* Msg_Login_C2S::release_szname() {
  clear_has_szname();
  if (szname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = szname_;
    szname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Msg_Login_C2S::set_allocated_szname(::std::string* szname) {
  if (szname_ != &::google::protobuf::internal::kEmptyString) {
    delete szname_;
  }
  if (szname) {
    set_has_szname();
    szname_ = szname;
  } else {
    clear_has_szname();
    szname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string szPassWord = 3;
inline bool Msg_Login_C2S::has_szpassword() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Msg_Login_C2S::set_has_szpassword() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Msg_Login_C2S::clear_has_szpassword() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Msg_Login_C2S::clear_szpassword() {
  if (szpassword_ != &::google::protobuf::internal::kEmptyString) {
    szpassword_->clear();
  }
  clear_has_szpassword();
}
inline const ::std::string& Msg_Login_C2S::szpassword() const {
  return *szpassword_;
}
inline void Msg_Login_C2S::set_szpassword(const ::std::string& value) {
  set_has_szpassword();
  if (szpassword_ == &::google::protobuf::internal::kEmptyString) {
    szpassword_ = new ::std::string;
  }
  szpassword_->assign(value);
}
inline void Msg_Login_C2S::set_szpassword(const char* value) {
  set_has_szpassword();
  if (szpassword_ == &::google::protobuf::internal::kEmptyString) {
    szpassword_ = new ::std::string;
  }
  szpassword_->assign(value);
}
inline void Msg_Login_C2S::set_szpassword(const char* value, size_t size) {
  set_has_szpassword();
  if (szpassword_ == &::google::protobuf::internal::kEmptyString) {
    szpassword_ = new ::std::string;
  }
  szpassword_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Msg_Login_C2S::mutable_szpassword() {
  set_has_szpassword();
  if (szpassword_ == &::google::protobuf::internal::kEmptyString) {
    szpassword_ = new ::std::string;
  }
  return szpassword_;
}
inline ::std::string* Msg_Login_C2S::release_szpassword() {
  clear_has_szpassword();
  if (szpassword_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = szpassword_;
    szpassword_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Msg_Login_C2S::set_allocated_szpassword(::std::string* szpassword) {
  if (szpassword_ != &::google::protobuf::internal::kEmptyString) {
    delete szpassword_;
  }
  if (szpassword) {
    set_has_szpassword();
    szpassword_ = szpassword;
  } else {
    clear_has_szpassword();
    szpassword_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// Msg_Login_S2C

// required fixed32 clientId = 1;
inline bool Msg_Login_S2C::has_clientid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Msg_Login_S2C::set_has_clientid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Msg_Login_S2C::clear_has_clientid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Msg_Login_S2C::clear_clientid() {
  clientid_ = 0u;
  clear_has_clientid();
}
inline ::google::protobuf::uint32 Msg_Login_S2C::clientid() const {
  return clientid_;
}
inline void Msg_Login_S2C::set_clientid(::google::protobuf::uint32 value) {
  set_has_clientid();
  clientid_ = value;
}

// required bool conSuccess = 2;
inline bool Msg_Login_S2C::has_consuccess() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Msg_Login_S2C::set_has_consuccess() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Msg_Login_S2C::clear_has_consuccess() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Msg_Login_S2C::clear_consuccess() {
  consuccess_ = false;
  clear_has_consuccess();
}
inline bool Msg_Login_S2C::consuccess() const {
  return consuccess_;
}
inline void Msg_Login_S2C::set_consuccess(bool value) {
  set_has_consuccess();
  consuccess_ = value;
}

// -------------------------------------------------------------------

// Msg_WorldChat_C2S

// required string szName = 1;
inline bool Msg_WorldChat_C2S::has_szname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Msg_WorldChat_C2S::set_has_szname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Msg_WorldChat_C2S::clear_has_szname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Msg_WorldChat_C2S::clear_szname() {
  if (szname_ != &::google::protobuf::internal::kEmptyString) {
    szname_->clear();
  }
  clear_has_szname();
}
inline const ::std::string& Msg_WorldChat_C2S::szname() const {
  return *szname_;
}
inline void Msg_WorldChat_C2S::set_szname(const ::std::string& value) {
  set_has_szname();
  if (szname_ == &::google::protobuf::internal::kEmptyString) {
    szname_ = new ::std::string;
  }
  szname_->assign(value);
}
inline void Msg_WorldChat_C2S::set_szname(const char* value) {
  set_has_szname();
  if (szname_ == &::google::protobuf::internal::kEmptyString) {
    szname_ = new ::std::string;
  }
  szname_->assign(value);
}
inline void Msg_WorldChat_C2S::set_szname(const char* value, size_t size) {
  set_has_szname();
  if (szname_ == &::google::protobuf::internal::kEmptyString) {
    szname_ = new ::std::string;
  }
  szname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Msg_WorldChat_C2S::mutable_szname() {
  set_has_szname();
  if (szname_ == &::google::protobuf::internal::kEmptyString) {
    szname_ = new ::std::string;
  }
  return szname_;
}
inline ::std::string* Msg_WorldChat_C2S::release_szname() {
  clear_has_szname();
  if (szname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = szname_;
    szname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Msg_WorldChat_C2S::set_allocated_szname(::std::string* szname) {
  if (szname_ != &::google::protobuf::internal::kEmptyString) {
    delete szname_;
  }
  if (szname) {
    set_has_szname();
    szname_ = szname;
  } else {
    clear_has_szname();
    szname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required fixed32 ID = 2;
inline bool Msg_WorldChat_C2S::has_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Msg_WorldChat_C2S::set_has_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Msg_WorldChat_C2S::clear_has_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Msg_WorldChat_C2S::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 Msg_WorldChat_C2S::id() const {
  return id_;
}
inline void Msg_WorldChat_C2S::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
}

// required string szText = 3;
inline bool Msg_WorldChat_C2S::has_sztext() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Msg_WorldChat_C2S::set_has_sztext() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Msg_WorldChat_C2S::clear_has_sztext() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Msg_WorldChat_C2S::clear_sztext() {
  if (sztext_ != &::google::protobuf::internal::kEmptyString) {
    sztext_->clear();
  }
  clear_has_sztext();
}
inline const ::std::string& Msg_WorldChat_C2S::sztext() const {
  return *sztext_;
}
inline void Msg_WorldChat_C2S::set_sztext(const ::std::string& value) {
  set_has_sztext();
  if (sztext_ == &::google::protobuf::internal::kEmptyString) {
    sztext_ = new ::std::string;
  }
  sztext_->assign(value);
}
inline void Msg_WorldChat_C2S::set_sztext(const char* value) {
  set_has_sztext();
  if (sztext_ == &::google::protobuf::internal::kEmptyString) {
    sztext_ = new ::std::string;
  }
  sztext_->assign(value);
}
inline void Msg_WorldChat_C2S::set_sztext(const char* value, size_t size) {
  set_has_sztext();
  if (sztext_ == &::google::protobuf::internal::kEmptyString) {
    sztext_ = new ::std::string;
  }
  sztext_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Msg_WorldChat_C2S::mutable_sztext() {
  set_has_sztext();
  if (sztext_ == &::google::protobuf::internal::kEmptyString) {
    sztext_ = new ::std::string;
  }
  return sztext_;
}
inline ::std::string* Msg_WorldChat_C2S::release_sztext() {
  clear_has_sztext();
  if (sztext_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = sztext_;
    sztext_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Msg_WorldChat_C2S::set_allocated_sztext(::std::string* sztext) {
  if (sztext_ != &::google::protobuf::internal::kEmptyString) {
    delete sztext_;
  }
  if (sztext) {
    set_has_sztext();
    sztext_ = sztext;
  } else {
    clear_has_sztext();
    sztext_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// Msg_WorldChat_S2C

// required string szName = 1;
inline bool Msg_WorldChat_S2C::has_szname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Msg_WorldChat_S2C::set_has_szname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Msg_WorldChat_S2C::clear_has_szname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Msg_WorldChat_S2C::clear_szname() {
  if (szname_ != &::google::protobuf::internal::kEmptyString) {
    szname_->clear();
  }
  clear_has_szname();
}
inline const ::std::string& Msg_WorldChat_S2C::szname() const {
  return *szname_;
}
inline void Msg_WorldChat_S2C::set_szname(const ::std::string& value) {
  set_has_szname();
  if (szname_ == &::google::protobuf::internal::kEmptyString) {
    szname_ = new ::std::string;
  }
  szname_->assign(value);
}
inline void Msg_WorldChat_S2C::set_szname(const char* value) {
  set_has_szname();
  if (szname_ == &::google::protobuf::internal::kEmptyString) {
    szname_ = new ::std::string;
  }
  szname_->assign(value);
}
inline void Msg_WorldChat_S2C::set_szname(const char* value, size_t size) {
  set_has_szname();
  if (szname_ == &::google::protobuf::internal::kEmptyString) {
    szname_ = new ::std::string;
  }
  szname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Msg_WorldChat_S2C::mutable_szname() {
  set_has_szname();
  if (szname_ == &::google::protobuf::internal::kEmptyString) {
    szname_ = new ::std::string;
  }
  return szname_;
}
inline ::std::string* Msg_WorldChat_S2C::release_szname() {
  clear_has_szname();
  if (szname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = szname_;
    szname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Msg_WorldChat_S2C::set_allocated_szname(::std::string* szname) {
  if (szname_ != &::google::protobuf::internal::kEmptyString) {
    delete szname_;
  }
  if (szname) {
    set_has_szname();
    szname_ = szname;
  } else {
    clear_has_szname();
    szname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required fixed32 ID = 2;
inline bool Msg_WorldChat_S2C::has_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Msg_WorldChat_S2C::set_has_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Msg_WorldChat_S2C::clear_has_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Msg_WorldChat_S2C::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 Msg_WorldChat_S2C::id() const {
  return id_;
}
inline void Msg_WorldChat_S2C::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
}

// required string szText = 3;
inline bool Msg_WorldChat_S2C::has_sztext() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Msg_WorldChat_S2C::set_has_sztext() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Msg_WorldChat_S2C::clear_has_sztext() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Msg_WorldChat_S2C::clear_sztext() {
  if (sztext_ != &::google::protobuf::internal::kEmptyString) {
    sztext_->clear();
  }
  clear_has_sztext();
}
inline const ::std::string& Msg_WorldChat_S2C::sztext() const {
  return *sztext_;
}
inline void Msg_WorldChat_S2C::set_sztext(const ::std::string& value) {
  set_has_sztext();
  if (sztext_ == &::google::protobuf::internal::kEmptyString) {
    sztext_ = new ::std::string;
  }
  sztext_->assign(value);
}
inline void Msg_WorldChat_S2C::set_sztext(const char* value) {
  set_has_sztext();
  if (sztext_ == &::google::protobuf::internal::kEmptyString) {
    sztext_ = new ::std::string;
  }
  sztext_->assign(value);
}
inline void Msg_WorldChat_S2C::set_sztext(const char* value, size_t size) {
  set_has_sztext();
  if (sztext_ == &::google::protobuf::internal::kEmptyString) {
    sztext_ = new ::std::string;
  }
  sztext_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Msg_WorldChat_S2C::mutable_sztext() {
  set_has_sztext();
  if (sztext_ == &::google::protobuf::internal::kEmptyString) {
    sztext_ = new ::std::string;
  }
  return sztext_;
}
inline ::std::string* Msg_WorldChat_S2C::release_sztext() {
  clear_has_sztext();
  if (sztext_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = sztext_;
    sztext_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Msg_WorldChat_S2C::set_allocated_sztext(::std::string* sztext) {
  if (sztext_ != &::google::protobuf::internal::kEmptyString) {
    delete sztext_;
  }
  if (sztext) {
    set_has_sztext();
    sztext_ = sztext;
  } else {
    clear_has_sztext();
    sztext_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// Msg_RoomChat_C2R

// required string szName = 1;
inline bool Msg_RoomChat_C2R::has_szname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Msg_RoomChat_C2R::set_has_szname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Msg_RoomChat_C2R::clear_has_szname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Msg_RoomChat_C2R::clear_szname() {
  if (szname_ != &::google::protobuf::internal::kEmptyString) {
    szname_->clear();
  }
  clear_has_szname();
}
inline const ::std::string& Msg_RoomChat_C2R::szname() const {
  return *szname_;
}
inline void Msg_RoomChat_C2R::set_szname(const ::std::string& value) {
  set_has_szname();
  if (szname_ == &::google::protobuf::internal::kEmptyString) {
    szname_ = new ::std::string;
  }
  szname_->assign(value);
}
inline void Msg_RoomChat_C2R::set_szname(const char* value) {
  set_has_szname();
  if (szname_ == &::google::protobuf::internal::kEmptyString) {
    szname_ = new ::std::string;
  }
  szname_->assign(value);
}
inline void Msg_RoomChat_C2R::set_szname(const char* value, size_t size) {
  set_has_szname();
  if (szname_ == &::google::protobuf::internal::kEmptyString) {
    szname_ = new ::std::string;
  }
  szname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Msg_RoomChat_C2R::mutable_szname() {
  set_has_szname();
  if (szname_ == &::google::protobuf::internal::kEmptyString) {
    szname_ = new ::std::string;
  }
  return szname_;
}
inline ::std::string* Msg_RoomChat_C2R::release_szname() {
  clear_has_szname();
  if (szname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = szname_;
    szname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Msg_RoomChat_C2R::set_allocated_szname(::std::string* szname) {
  if (szname_ != &::google::protobuf::internal::kEmptyString) {
    delete szname_;
  }
  if (szname) {
    set_has_szname();
    szname_ = szname;
  } else {
    clear_has_szname();
    szname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required fixed32 ID = 2;
inline bool Msg_RoomChat_C2R::has_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Msg_RoomChat_C2R::set_has_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Msg_RoomChat_C2R::clear_has_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Msg_RoomChat_C2R::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 Msg_RoomChat_C2R::id() const {
  return id_;
}
inline void Msg_RoomChat_C2R::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
}

// required fixed32 roomID = 3;
inline bool Msg_RoomChat_C2R::has_roomid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Msg_RoomChat_C2R::set_has_roomid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Msg_RoomChat_C2R::clear_has_roomid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Msg_RoomChat_C2R::clear_roomid() {
  roomid_ = 0u;
  clear_has_roomid();
}
inline ::google::protobuf::uint32 Msg_RoomChat_C2R::roomid() const {
  return roomid_;
}
inline void Msg_RoomChat_C2R::set_roomid(::google::protobuf::uint32 value) {
  set_has_roomid();
  roomid_ = value;
}

// required string szText = 4;
inline bool Msg_RoomChat_C2R::has_sztext() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Msg_RoomChat_C2R::set_has_sztext() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Msg_RoomChat_C2R::clear_has_sztext() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Msg_RoomChat_C2R::clear_sztext() {
  if (sztext_ != &::google::protobuf::internal::kEmptyString) {
    sztext_->clear();
  }
  clear_has_sztext();
}
inline const ::std::string& Msg_RoomChat_C2R::sztext() const {
  return *sztext_;
}
inline void Msg_RoomChat_C2R::set_sztext(const ::std::string& value) {
  set_has_sztext();
  if (sztext_ == &::google::protobuf::internal::kEmptyString) {
    sztext_ = new ::std::string;
  }
  sztext_->assign(value);
}
inline void Msg_RoomChat_C2R::set_sztext(const char* value) {
  set_has_sztext();
  if (sztext_ == &::google::protobuf::internal::kEmptyString) {
    sztext_ = new ::std::string;
  }
  sztext_->assign(value);
}
inline void Msg_RoomChat_C2R::set_sztext(const char* value, size_t size) {
  set_has_sztext();
  if (sztext_ == &::google::protobuf::internal::kEmptyString) {
    sztext_ = new ::std::string;
  }
  sztext_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Msg_RoomChat_C2R::mutable_sztext() {
  set_has_sztext();
  if (sztext_ == &::google::protobuf::internal::kEmptyString) {
    sztext_ = new ::std::string;
  }
  return sztext_;
}
inline ::std::string* Msg_RoomChat_C2R::release_sztext() {
  clear_has_sztext();
  if (sztext_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = sztext_;
    sztext_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Msg_RoomChat_C2R::set_allocated_sztext(::std::string* sztext) {
  if (sztext_ != &::google::protobuf::internal::kEmptyString) {
    delete sztext_;
  }
  if (sztext) {
    set_has_sztext();
    sztext_ = sztext;
  } else {
    clear_has_sztext();
    sztext_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// Msg_RoomChat_R2C

// required string szName = 1;
inline bool Msg_RoomChat_R2C::has_szname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Msg_RoomChat_R2C::set_has_szname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Msg_RoomChat_R2C::clear_has_szname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Msg_RoomChat_R2C::clear_szname() {
  if (szname_ != &::google::protobuf::internal::kEmptyString) {
    szname_->clear();
  }
  clear_has_szname();
}
inline const ::std::string& Msg_RoomChat_R2C::szname() const {
  return *szname_;
}
inline void Msg_RoomChat_R2C::set_szname(const ::std::string& value) {
  set_has_szname();
  if (szname_ == &::google::protobuf::internal::kEmptyString) {
    szname_ = new ::std::string;
  }
  szname_->assign(value);
}
inline void Msg_RoomChat_R2C::set_szname(const char* value) {
  set_has_szname();
  if (szname_ == &::google::protobuf::internal::kEmptyString) {
    szname_ = new ::std::string;
  }
  szname_->assign(value);
}
inline void Msg_RoomChat_R2C::set_szname(const char* value, size_t size) {
  set_has_szname();
  if (szname_ == &::google::protobuf::internal::kEmptyString) {
    szname_ = new ::std::string;
  }
  szname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Msg_RoomChat_R2C::mutable_szname() {
  set_has_szname();
  if (szname_ == &::google::protobuf::internal::kEmptyString) {
    szname_ = new ::std::string;
  }
  return szname_;
}
inline ::std::string* Msg_RoomChat_R2C::release_szname() {
  clear_has_szname();
  if (szname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = szname_;
    szname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Msg_RoomChat_R2C::set_allocated_szname(::std::string* szname) {
  if (szname_ != &::google::protobuf::internal::kEmptyString) {
    delete szname_;
  }
  if (szname) {
    set_has_szname();
    szname_ = szname;
  } else {
    clear_has_szname();
    szname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required fixed32 ID = 2;
inline bool Msg_RoomChat_R2C::has_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Msg_RoomChat_R2C::set_has_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Msg_RoomChat_R2C::clear_has_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Msg_RoomChat_R2C::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 Msg_RoomChat_R2C::id() const {
  return id_;
}
inline void Msg_RoomChat_R2C::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
}

// required fixed32 roomID = 3;
inline bool Msg_RoomChat_R2C::has_roomid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Msg_RoomChat_R2C::set_has_roomid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Msg_RoomChat_R2C::clear_has_roomid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Msg_RoomChat_R2C::clear_roomid() {
  roomid_ = 0u;
  clear_has_roomid();
}
inline ::google::protobuf::uint32 Msg_RoomChat_R2C::roomid() const {
  return roomid_;
}
inline void Msg_RoomChat_R2C::set_roomid(::google::protobuf::uint32 value) {
  set_has_roomid();
  roomid_ = value;
}

// required string szText = 4;
inline bool Msg_RoomChat_R2C::has_sztext() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Msg_RoomChat_R2C::set_has_sztext() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Msg_RoomChat_R2C::clear_has_sztext() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Msg_RoomChat_R2C::clear_sztext() {
  if (sztext_ != &::google::protobuf::internal::kEmptyString) {
    sztext_->clear();
  }
  clear_has_sztext();
}
inline const ::std::string& Msg_RoomChat_R2C::sztext() const {
  return *sztext_;
}
inline void Msg_RoomChat_R2C::set_sztext(const ::std::string& value) {
  set_has_sztext();
  if (sztext_ == &::google::protobuf::internal::kEmptyString) {
    sztext_ = new ::std::string;
  }
  sztext_->assign(value);
}
inline void Msg_RoomChat_R2C::set_sztext(const char* value) {
  set_has_sztext();
  if (sztext_ == &::google::protobuf::internal::kEmptyString) {
    sztext_ = new ::std::string;
  }
  sztext_->assign(value);
}
inline void Msg_RoomChat_R2C::set_sztext(const char* value, size_t size) {
  set_has_sztext();
  if (sztext_ == &::google::protobuf::internal::kEmptyString) {
    sztext_ = new ::std::string;
  }
  sztext_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Msg_RoomChat_R2C::mutable_sztext() {
  set_has_sztext();
  if (sztext_ == &::google::protobuf::internal::kEmptyString) {
    sztext_ = new ::std::string;
  }
  return sztext_;
}
inline ::std::string* Msg_RoomChat_R2C::release_sztext() {
  clear_has_sztext();
  if (sztext_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = sztext_;
    sztext_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Msg_RoomChat_R2C::set_allocated_sztext(::std::string* sztext) {
  if (sztext_ != &::google::protobuf::internal::kEmptyString) {
    delete sztext_;
  }
  if (sztext) {
    set_has_sztext();
    sztext_ = sztext;
  } else {
    clear_has_sztext();
    sztext_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// Msg_PrivateChat_C2C

// required string szName = 1;
inline bool Msg_PrivateChat_C2C::has_szname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Msg_PrivateChat_C2C::set_has_szname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Msg_PrivateChat_C2C::clear_has_szname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Msg_PrivateChat_C2C::clear_szname() {
  if (szname_ != &::google::protobuf::internal::kEmptyString) {
    szname_->clear();
  }
  clear_has_szname();
}
inline const ::std::string& Msg_PrivateChat_C2C::szname() const {
  return *szname_;
}
inline void Msg_PrivateChat_C2C::set_szname(const ::std::string& value) {
  set_has_szname();
  if (szname_ == &::google::protobuf::internal::kEmptyString) {
    szname_ = new ::std::string;
  }
  szname_->assign(value);
}
inline void Msg_PrivateChat_C2C::set_szname(const char* value) {
  set_has_szname();
  if (szname_ == &::google::protobuf::internal::kEmptyString) {
    szname_ = new ::std::string;
  }
  szname_->assign(value);
}
inline void Msg_PrivateChat_C2C::set_szname(const char* value, size_t size) {
  set_has_szname();
  if (szname_ == &::google::protobuf::internal::kEmptyString) {
    szname_ = new ::std::string;
  }
  szname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Msg_PrivateChat_C2C::mutable_szname() {
  set_has_szname();
  if (szname_ == &::google::protobuf::internal::kEmptyString) {
    szname_ = new ::std::string;
  }
  return szname_;
}
inline ::std::string* Msg_PrivateChat_C2C::release_szname() {
  clear_has_szname();
  if (szname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = szname_;
    szname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Msg_PrivateChat_C2C::set_allocated_szname(::std::string* szname) {
  if (szname_ != &::google::protobuf::internal::kEmptyString) {
    delete szname_;
  }
  if (szname) {
    set_has_szname();
    szname_ = szname;
  } else {
    clear_has_szname();
    szname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required fixed32 ID = 2;
inline bool Msg_PrivateChat_C2C::has_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Msg_PrivateChat_C2C::set_has_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Msg_PrivateChat_C2C::clear_has_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Msg_PrivateChat_C2C::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 Msg_PrivateChat_C2C::id() const {
  return id_;
}
inline void Msg_PrivateChat_C2C::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
}

// required fixed32 targetID = 3;
inline bool Msg_PrivateChat_C2C::has_targetid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Msg_PrivateChat_C2C::set_has_targetid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Msg_PrivateChat_C2C::clear_has_targetid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Msg_PrivateChat_C2C::clear_targetid() {
  targetid_ = 0u;
  clear_has_targetid();
}
inline ::google::protobuf::uint32 Msg_PrivateChat_C2C::targetid() const {
  return targetid_;
}
inline void Msg_PrivateChat_C2C::set_targetid(::google::protobuf::uint32 value) {
  set_has_targetid();
  targetid_ = value;
}

// required string szText = 4;
inline bool Msg_PrivateChat_C2C::has_sztext() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Msg_PrivateChat_C2C::set_has_sztext() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Msg_PrivateChat_C2C::clear_has_sztext() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Msg_PrivateChat_C2C::clear_sztext() {
  if (sztext_ != &::google::protobuf::internal::kEmptyString) {
    sztext_->clear();
  }
  clear_has_sztext();
}
inline const ::std::string& Msg_PrivateChat_C2C::sztext() const {
  return *sztext_;
}
inline void Msg_PrivateChat_C2C::set_sztext(const ::std::string& value) {
  set_has_sztext();
  if (sztext_ == &::google::protobuf::internal::kEmptyString) {
    sztext_ = new ::std::string;
  }
  sztext_->assign(value);
}
inline void Msg_PrivateChat_C2C::set_sztext(const char* value) {
  set_has_sztext();
  if (sztext_ == &::google::protobuf::internal::kEmptyString) {
    sztext_ = new ::std::string;
  }
  sztext_->assign(value);
}
inline void Msg_PrivateChat_C2C::set_sztext(const char* value, size_t size) {
  set_has_sztext();
  if (sztext_ == &::google::protobuf::internal::kEmptyString) {
    sztext_ = new ::std::string;
  }
  sztext_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Msg_PrivateChat_C2C::mutable_sztext() {
  set_has_sztext();
  if (sztext_ == &::google::protobuf::internal::kEmptyString) {
    sztext_ = new ::std::string;
  }
  return sztext_;
}
inline ::std::string* Msg_PrivateChat_C2C::release_sztext() {
  clear_has_sztext();
  if (sztext_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = sztext_;
    sztext_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Msg_PrivateChat_C2C::set_allocated_sztext(::std::string* sztext) {
  if (sztext_ != &::google::protobuf::internal::kEmptyString) {
    delete sztext_;
  }
  if (sztext) {
    set_has_sztext();
    sztext_ = sztext;
  } else {
    clear_has_sztext();
    sztext_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// Msg_RoomOperate_C2S

// required fixed32 ID = 1;
inline bool Msg_RoomOperate_C2S::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Msg_RoomOperate_C2S::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Msg_RoomOperate_C2S::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Msg_RoomOperate_C2S::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 Msg_RoomOperate_C2S::id() const {
  return id_;
}
inline void Msg_RoomOperate_C2S::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
}

// required .RoomOperateType operateType = 2;
inline bool Msg_RoomOperate_C2S::has_operatetype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Msg_RoomOperate_C2S::set_has_operatetype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Msg_RoomOperate_C2S::clear_has_operatetype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Msg_RoomOperate_C2S::clear_operatetype() {
  operatetype_ = 0;
  clear_has_operatetype();
}
inline ::RoomOperateType Msg_RoomOperate_C2S::operatetype() const {
  return static_cast< ::RoomOperateType >(operatetype_);
}
inline void Msg_RoomOperate_C2S::set_operatetype(::RoomOperateType value) {
  assert(::RoomOperateType_IsValid(value));
  set_has_operatetype();
  operatetype_ = value;
}

// optional fixed32 roomID = 3;
inline bool Msg_RoomOperate_C2S::has_roomid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Msg_RoomOperate_C2S::set_has_roomid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Msg_RoomOperate_C2S::clear_has_roomid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Msg_RoomOperate_C2S::clear_roomid() {
  roomid_ = 0u;
  clear_has_roomid();
}
inline ::google::protobuf::uint32 Msg_RoomOperate_C2S::roomid() const {
  return roomid_;
}
inline void Msg_RoomOperate_C2S::set_roomid(::google::protobuf::uint32 value) {
  set_has_roomid();
  roomid_ = value;
}

// optional string roomName = 4;
inline bool Msg_RoomOperate_C2S::has_roomname() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Msg_RoomOperate_C2S::set_has_roomname() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Msg_RoomOperate_C2S::clear_has_roomname() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Msg_RoomOperate_C2S::clear_roomname() {
  if (roomname_ != &::google::protobuf::internal::kEmptyString) {
    roomname_->clear();
  }
  clear_has_roomname();
}
inline const ::std::string& Msg_RoomOperate_C2S::roomname() const {
  return *roomname_;
}
inline void Msg_RoomOperate_C2S::set_roomname(const ::std::string& value) {
  set_has_roomname();
  if (roomname_ == &::google::protobuf::internal::kEmptyString) {
    roomname_ = new ::std::string;
  }
  roomname_->assign(value);
}
inline void Msg_RoomOperate_C2S::set_roomname(const char* value) {
  set_has_roomname();
  if (roomname_ == &::google::protobuf::internal::kEmptyString) {
    roomname_ = new ::std::string;
  }
  roomname_->assign(value);
}
inline void Msg_RoomOperate_C2S::set_roomname(const char* value, size_t size) {
  set_has_roomname();
  if (roomname_ == &::google::protobuf::internal::kEmptyString) {
    roomname_ = new ::std::string;
  }
  roomname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Msg_RoomOperate_C2S::mutable_roomname() {
  set_has_roomname();
  if (roomname_ == &::google::protobuf::internal::kEmptyString) {
    roomname_ = new ::std::string;
  }
  return roomname_;
}
inline ::std::string* Msg_RoomOperate_C2S::release_roomname() {
  clear_has_roomname();
  if (roomname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = roomname_;
    roomname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Msg_RoomOperate_C2S::set_allocated_roomname(::std::string* roomname) {
  if (roomname_ != &::google::protobuf::internal::kEmptyString) {
    delete roomname_;
  }
  if (roomname) {
    set_has_roomname();
    roomname_ = roomname;
  } else {
    clear_has_roomname();
    roomname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional fixed32 roomUserNumber = 5;
inline bool Msg_RoomOperate_C2S::has_roomusernumber() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Msg_RoomOperate_C2S::set_has_roomusernumber() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Msg_RoomOperate_C2S::clear_has_roomusernumber() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Msg_RoomOperate_C2S::clear_roomusernumber() {
  roomusernumber_ = 0u;
  clear_has_roomusernumber();
}
inline ::google::protobuf::uint32 Msg_RoomOperate_C2S::roomusernumber() const {
  return roomusernumber_;
}
inline void Msg_RoomOperate_C2S::set_roomusernumber(::google::protobuf::uint32 value) {
  set_has_roomusernumber();
  roomusernumber_ = value;
}

// optional .GamePattern roomPattern = 6;
inline bool Msg_RoomOperate_C2S::has_roompattern() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Msg_RoomOperate_C2S::set_has_roompattern() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Msg_RoomOperate_C2S::clear_has_roompattern() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Msg_RoomOperate_C2S::clear_roompattern() {
  roompattern_ = 0;
  clear_has_roompattern();
}
inline ::GamePattern Msg_RoomOperate_C2S::roompattern() const {
  return static_cast< ::GamePattern >(roompattern_);
}
inline void Msg_RoomOperate_C2S::set_roompattern(::GamePattern value) {
  assert(::GamePattern_IsValid(value));
  set_has_roompattern();
  roompattern_ = value;
}

// optional string Map = 7;
inline bool Msg_RoomOperate_C2S::has_map() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Msg_RoomOperate_C2S::set_has_map() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Msg_RoomOperate_C2S::clear_has_map() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Msg_RoomOperate_C2S::clear_map() {
  if (map_ != &::google::protobuf::internal::kEmptyString) {
    map_->clear();
  }
  clear_has_map();
}
inline const ::std::string& Msg_RoomOperate_C2S::map() const {
  return *map_;
}
inline void Msg_RoomOperate_C2S::set_map(const ::std::string& value) {
  set_has_map();
  if (map_ == &::google::protobuf::internal::kEmptyString) {
    map_ = new ::std::string;
  }
  map_->assign(value);
}
inline void Msg_RoomOperate_C2S::set_map(const char* value) {
  set_has_map();
  if (map_ == &::google::protobuf::internal::kEmptyString) {
    map_ = new ::std::string;
  }
  map_->assign(value);
}
inline void Msg_RoomOperate_C2S::set_map(const char* value, size_t size) {
  set_has_map();
  if (map_ == &::google::protobuf::internal::kEmptyString) {
    map_ = new ::std::string;
  }
  map_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Msg_RoomOperate_C2S::mutable_map() {
  set_has_map();
  if (map_ == &::google::protobuf::internal::kEmptyString) {
    map_ = new ::std::string;
  }
  return map_;
}
inline ::std::string* Msg_RoomOperate_C2S::release_map() {
  clear_has_map();
  if (map_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = map_;
    map_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Msg_RoomOperate_C2S::set_allocated_map(::std::string* map) {
  if (map_ != &::google::protobuf::internal::kEmptyString) {
    delete map_;
  }
  if (map) {
    set_has_map();
    map_ = map;
  } else {
    clear_has_map();
    map_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// Msg_RoomOperate_S2C

// required fixed32 ID = 1;
inline bool Msg_RoomOperate_S2C::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Msg_RoomOperate_S2C::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Msg_RoomOperate_S2C::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Msg_RoomOperate_S2C::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 Msg_RoomOperate_S2C::id() const {
  return id_;
}
inline void Msg_RoomOperate_S2C::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
}

// required .RoomOperateType operateType = 2;
inline bool Msg_RoomOperate_S2C::has_operatetype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Msg_RoomOperate_S2C::set_has_operatetype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Msg_RoomOperate_S2C::clear_has_operatetype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Msg_RoomOperate_S2C::clear_operatetype() {
  operatetype_ = 0;
  clear_has_operatetype();
}
inline ::RoomOperateType Msg_RoomOperate_S2C::operatetype() const {
  return static_cast< ::RoomOperateType >(operatetype_);
}
inline void Msg_RoomOperate_S2C::set_operatetype(::RoomOperateType value) {
  assert(::RoomOperateType_IsValid(value));
  set_has_operatetype();
  operatetype_ = value;
}

// required fixed32 roomID = 3;
inline bool Msg_RoomOperate_S2C::has_roomid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Msg_RoomOperate_S2C::set_has_roomid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Msg_RoomOperate_S2C::clear_has_roomid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Msg_RoomOperate_S2C::clear_roomid() {
  roomid_ = 0u;
  clear_has_roomid();
}
inline ::google::protobuf::uint32 Msg_RoomOperate_S2C::roomid() const {
  return roomid_;
}
inline void Msg_RoomOperate_S2C::set_roomid(::google::protobuf::uint32 value) {
  set_has_roomid();
  roomid_ = value;
}

// required bool success = 4;
inline bool Msg_RoomOperate_S2C::has_success() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Msg_RoomOperate_S2C::set_has_success() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Msg_RoomOperate_S2C::clear_has_success() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Msg_RoomOperate_S2C::clear_success() {
  success_ = false;
  clear_has_success();
}
inline bool Msg_RoomOperate_S2C::success() const {
  return success_;
}
inline void Msg_RoomOperate_S2C::set_success(bool value) {
  set_has_success();
  success_ = value;
}

// optional string roomName = 5;
inline bool Msg_RoomOperate_S2C::has_roomname() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Msg_RoomOperate_S2C::set_has_roomname() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Msg_RoomOperate_S2C::clear_has_roomname() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Msg_RoomOperate_S2C::clear_roomname() {
  if (roomname_ != &::google::protobuf::internal::kEmptyString) {
    roomname_->clear();
  }
  clear_has_roomname();
}
inline const ::std::string& Msg_RoomOperate_S2C::roomname() const {
  return *roomname_;
}
inline void Msg_RoomOperate_S2C::set_roomname(const ::std::string& value) {
  set_has_roomname();
  if (roomname_ == &::google::protobuf::internal::kEmptyString) {
    roomname_ = new ::std::string;
  }
  roomname_->assign(value);
}
inline void Msg_RoomOperate_S2C::set_roomname(const char* value) {
  set_has_roomname();
  if (roomname_ == &::google::protobuf::internal::kEmptyString) {
    roomname_ = new ::std::string;
  }
  roomname_->assign(value);
}
inline void Msg_RoomOperate_S2C::set_roomname(const char* value, size_t size) {
  set_has_roomname();
  if (roomname_ == &::google::protobuf::internal::kEmptyString) {
    roomname_ = new ::std::string;
  }
  roomname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Msg_RoomOperate_S2C::mutable_roomname() {
  set_has_roomname();
  if (roomname_ == &::google::protobuf::internal::kEmptyString) {
    roomname_ = new ::std::string;
  }
  return roomname_;
}
inline ::std::string* Msg_RoomOperate_S2C::release_roomname() {
  clear_has_roomname();
  if (roomname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = roomname_;
    roomname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Msg_RoomOperate_S2C::set_allocated_roomname(::std::string* roomname) {
  if (roomname_ != &::google::protobuf::internal::kEmptyString) {
    delete roomname_;
  }
  if (roomname) {
    set_has_roomname();
    roomname_ = roomname;
  } else {
    clear_has_roomname();
    roomname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional fixed32 roomUserNumber = 6;
inline bool Msg_RoomOperate_S2C::has_roomusernumber() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Msg_RoomOperate_S2C::set_has_roomusernumber() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Msg_RoomOperate_S2C::clear_has_roomusernumber() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Msg_RoomOperate_S2C::clear_roomusernumber() {
  roomusernumber_ = 0u;
  clear_has_roomusernumber();
}
inline ::google::protobuf::uint32 Msg_RoomOperate_S2C::roomusernumber() const {
  return roomusernumber_;
}
inline void Msg_RoomOperate_S2C::set_roomusernumber(::google::protobuf::uint32 value) {
  set_has_roomusernumber();
  roomusernumber_ = value;
}

// optional .GamePattern roomPattern = 7;
inline bool Msg_RoomOperate_S2C::has_roompattern() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Msg_RoomOperate_S2C::set_has_roompattern() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Msg_RoomOperate_S2C::clear_has_roompattern() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Msg_RoomOperate_S2C::clear_roompattern() {
  roompattern_ = 0;
  clear_has_roompattern();
}
inline ::GamePattern Msg_RoomOperate_S2C::roompattern() const {
  return static_cast< ::GamePattern >(roompattern_);
}
inline void Msg_RoomOperate_S2C::set_roompattern(::GamePattern value) {
  assert(::GamePattern_IsValid(value));
  set_has_roompattern();
  roompattern_ = value;
}

// repeated .protoaccount players = 8;
inline int Msg_RoomOperate_S2C::players_size() const {
  return players_.size();
}
inline void Msg_RoomOperate_S2C::clear_players() {
  players_.Clear();
}
inline const ::protoaccount& Msg_RoomOperate_S2C::players(int index) const {
  return players_.Get(index);
}
inline ::protoaccount* Msg_RoomOperate_S2C::mutable_players(int index) {
  return players_.Mutable(index);
}
inline ::protoaccount* Msg_RoomOperate_S2C::add_players() {
  return players_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::protoaccount >&
Msg_RoomOperate_S2C::players() const {
  return players_;
}
inline ::google::protobuf::RepeatedPtrField< ::protoaccount >*
Msg_RoomOperate_S2C::mutable_players() {
  return &players_;
}

// optional string Map = 9;
inline bool Msg_RoomOperate_S2C::has_map() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Msg_RoomOperate_S2C::set_has_map() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Msg_RoomOperate_S2C::clear_has_map() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Msg_RoomOperate_S2C::clear_map() {
  if (map_ != &::google::protobuf::internal::kEmptyString) {
    map_->clear();
  }
  clear_has_map();
}
inline const ::std::string& Msg_RoomOperate_S2C::map() const {
  return *map_;
}
inline void Msg_RoomOperate_S2C::set_map(const ::std::string& value) {
  set_has_map();
  if (map_ == &::google::protobuf::internal::kEmptyString) {
    map_ = new ::std::string;
  }
  map_->assign(value);
}
inline void Msg_RoomOperate_S2C::set_map(const char* value) {
  set_has_map();
  if (map_ == &::google::protobuf::internal::kEmptyString) {
    map_ = new ::std::string;
  }
  map_->assign(value);
}
inline void Msg_RoomOperate_S2C::set_map(const char* value, size_t size) {
  set_has_map();
  if (map_ == &::google::protobuf::internal::kEmptyString) {
    map_ = new ::std::string;
  }
  map_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Msg_RoomOperate_S2C::mutable_map() {
  set_has_map();
  if (map_ == &::google::protobuf::internal::kEmptyString) {
    map_ = new ::std::string;
  }
  return map_;
}
inline ::std::string* Msg_RoomOperate_S2C::release_map() {
  clear_has_map();
  if (map_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = map_;
    map_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Msg_RoomOperate_S2C::set_allocated_map(::std::string* map) {
  if (map_ != &::google::protobuf::internal::kEmptyString) {
    delete map_;
  }
  if (map) {
    set_has_map();
    map_ = map;
  } else {
    clear_has_map();
    map_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// Msg_StartBattle_C2S

// required string szName = 1;
inline bool Msg_StartBattle_C2S::has_szname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Msg_StartBattle_C2S::set_has_szname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Msg_StartBattle_C2S::clear_has_szname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Msg_StartBattle_C2S::clear_szname() {
  if (szname_ != &::google::protobuf::internal::kEmptyString) {
    szname_->clear();
  }
  clear_has_szname();
}
inline const ::std::string& Msg_StartBattle_C2S::szname() const {
  return *szname_;
}
inline void Msg_StartBattle_C2S::set_szname(const ::std::string& value) {
  set_has_szname();
  if (szname_ == &::google::protobuf::internal::kEmptyString) {
    szname_ = new ::std::string;
  }
  szname_->assign(value);
}
inline void Msg_StartBattle_C2S::set_szname(const char* value) {
  set_has_szname();
  if (szname_ == &::google::protobuf::internal::kEmptyString) {
    szname_ = new ::std::string;
  }
  szname_->assign(value);
}
inline void Msg_StartBattle_C2S::set_szname(const char* value, size_t size) {
  set_has_szname();
  if (szname_ == &::google::protobuf::internal::kEmptyString) {
    szname_ = new ::std::string;
  }
  szname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Msg_StartBattle_C2S::mutable_szname() {
  set_has_szname();
  if (szname_ == &::google::protobuf::internal::kEmptyString) {
    szname_ = new ::std::string;
  }
  return szname_;
}
inline ::std::string* Msg_StartBattle_C2S::release_szname() {
  clear_has_szname();
  if (szname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = szname_;
    szname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Msg_StartBattle_C2S::set_allocated_szname(::std::string* szname) {
  if (szname_ != &::google::protobuf::internal::kEmptyString) {
    delete szname_;
  }
  if (szname) {
    set_has_szname();
    szname_ = szname;
  } else {
    clear_has_szname();
    szname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required fixed32 ID = 2;
inline bool Msg_StartBattle_C2S::has_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Msg_StartBattle_C2S::set_has_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Msg_StartBattle_C2S::clear_has_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Msg_StartBattle_C2S::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 Msg_StartBattle_C2S::id() const {
  return id_;
}
inline void Msg_StartBattle_C2S::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
}

// required fixed32 ID2 = 3;
inline bool Msg_StartBattle_C2S::has_id2() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Msg_StartBattle_C2S::set_has_id2() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Msg_StartBattle_C2S::clear_has_id2() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Msg_StartBattle_C2S::clear_id2() {
  id2_ = 0u;
  clear_has_id2();
}
inline ::google::protobuf::uint32 Msg_StartBattle_C2S::id2() const {
  return id2_;
}
inline void Msg_StartBattle_C2S::set_id2(::google::protobuf::uint32 value) {
  set_has_id2();
  id2_ = value;
}

// required fixed32 roomID = 4;
inline bool Msg_StartBattle_C2S::has_roomid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Msg_StartBattle_C2S::set_has_roomid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Msg_StartBattle_C2S::clear_has_roomid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Msg_StartBattle_C2S::clear_roomid() {
  roomid_ = 0u;
  clear_has_roomid();
}
inline ::google::protobuf::uint32 Msg_StartBattle_C2S::roomid() const {
  return roomid_;
}
inline void Msg_StartBattle_C2S::set_roomid(::google::protobuf::uint32 value) {
  set_has_roomid();
  roomid_ = value;
}

// required .GamePattern pattern = 5;
inline bool Msg_StartBattle_C2S::has_pattern() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Msg_StartBattle_C2S::set_has_pattern() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Msg_StartBattle_C2S::clear_has_pattern() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Msg_StartBattle_C2S::clear_pattern() {
  pattern_ = 0;
  clear_has_pattern();
}
inline ::GamePattern Msg_StartBattle_C2S::pattern() const {
  return static_cast< ::GamePattern >(pattern_);
}
inline void Msg_StartBattle_C2S::set_pattern(::GamePattern value) {
  assert(::GamePattern_IsValid(value));
  set_has_pattern();
  pattern_ = value;
}

// -------------------------------------------------------------------

// Msg_StartBattle_S2C

// required string szName = 1;
inline bool Msg_StartBattle_S2C::has_szname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Msg_StartBattle_S2C::set_has_szname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Msg_StartBattle_S2C::clear_has_szname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Msg_StartBattle_S2C::clear_szname() {
  if (szname_ != &::google::protobuf::internal::kEmptyString) {
    szname_->clear();
  }
  clear_has_szname();
}
inline const ::std::string& Msg_StartBattle_S2C::szname() const {
  return *szname_;
}
inline void Msg_StartBattle_S2C::set_szname(const ::std::string& value) {
  set_has_szname();
  if (szname_ == &::google::protobuf::internal::kEmptyString) {
    szname_ = new ::std::string;
  }
  szname_->assign(value);
}
inline void Msg_StartBattle_S2C::set_szname(const char* value) {
  set_has_szname();
  if (szname_ == &::google::protobuf::internal::kEmptyString) {
    szname_ = new ::std::string;
  }
  szname_->assign(value);
}
inline void Msg_StartBattle_S2C::set_szname(const char* value, size_t size) {
  set_has_szname();
  if (szname_ == &::google::protobuf::internal::kEmptyString) {
    szname_ = new ::std::string;
  }
  szname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Msg_StartBattle_S2C::mutable_szname() {
  set_has_szname();
  if (szname_ == &::google::protobuf::internal::kEmptyString) {
    szname_ = new ::std::string;
  }
  return szname_;
}
inline ::std::string* Msg_StartBattle_S2C::release_szname() {
  clear_has_szname();
  if (szname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = szname_;
    szname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Msg_StartBattle_S2C::set_allocated_szname(::std::string* szname) {
  if (szname_ != &::google::protobuf::internal::kEmptyString) {
    delete szname_;
  }
  if (szname) {
    set_has_szname();
    szname_ = szname;
  } else {
    clear_has_szname();
    szname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required fixed32 ID = 2;
inline bool Msg_StartBattle_S2C::has_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Msg_StartBattle_S2C::set_has_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Msg_StartBattle_S2C::clear_has_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Msg_StartBattle_S2C::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 Msg_StartBattle_S2C::id() const {
  return id_;
}
inline void Msg_StartBattle_S2C::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
}

// required fixed32 ID2 = 3;
inline bool Msg_StartBattle_S2C::has_id2() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Msg_StartBattle_S2C::set_has_id2() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Msg_StartBattle_S2C::clear_has_id2() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Msg_StartBattle_S2C::clear_id2() {
  id2_ = 0u;
  clear_has_id2();
}
inline ::google::protobuf::uint32 Msg_StartBattle_S2C::id2() const {
  return id2_;
}
inline void Msg_StartBattle_S2C::set_id2(::google::protobuf::uint32 value) {
  set_has_id2();
  id2_ = value;
}

// required fixed32 roomID = 4;
inline bool Msg_StartBattle_S2C::has_roomid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Msg_StartBattle_S2C::set_has_roomid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Msg_StartBattle_S2C::clear_has_roomid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Msg_StartBattle_S2C::clear_roomid() {
  roomid_ = 0u;
  clear_has_roomid();
}
inline ::google::protobuf::uint32 Msg_StartBattle_S2C::roomid() const {
  return roomid_;
}
inline void Msg_StartBattle_S2C::set_roomid(::google::protobuf::uint32 value) {
  set_has_roomid();
  roomid_ = value;
}

// required .GamePattern pattern = 5;
inline bool Msg_StartBattle_S2C::has_pattern() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Msg_StartBattle_S2C::set_has_pattern() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Msg_StartBattle_S2C::clear_has_pattern() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Msg_StartBattle_S2C::clear_pattern() {
  pattern_ = 0;
  clear_has_pattern();
}
inline ::GamePattern Msg_StartBattle_S2C::pattern() const {
  return static_cast< ::GamePattern >(pattern_);
}
inline void Msg_StartBattle_S2C::set_pattern(::GamePattern value) {
  assert(::GamePattern_IsValid(value));
  set_has_pattern();
  pattern_ = value;
}

// required fixed32 BattleId = 6;
inline bool Msg_StartBattle_S2C::has_battleid() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Msg_StartBattle_S2C::set_has_battleid() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Msg_StartBattle_S2C::clear_has_battleid() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Msg_StartBattle_S2C::clear_battleid() {
  battleid_ = 0u;
  clear_has_battleid();
}
inline ::google::protobuf::uint32 Msg_StartBattle_S2C::battleid() const {
  return battleid_;
}
inline void Msg_StartBattle_S2C::set_battleid(::google::protobuf::uint32 value) {
  set_has_battleid();
  battleid_ = value;
}

// -------------------------------------------------------------------

// Msg_OriginHandCards_S2C

// required fixed32 playerid = 1;
inline bool Msg_OriginHandCards_S2C::has_playerid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Msg_OriginHandCards_S2C::set_has_playerid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Msg_OriginHandCards_S2C::clear_has_playerid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Msg_OriginHandCards_S2C::clear_playerid() {
  playerid_ = 0u;
  clear_has_playerid();
}
inline ::google::protobuf::uint32 Msg_OriginHandCards_S2C::playerid() const {
  return playerid_;
}
inline void Msg_OriginHandCards_S2C::set_playerid(::google::protobuf::uint32 value) {
  set_has_playerid();
  playerid_ = value;
}

// repeated .protocard cards = 2;
inline int Msg_OriginHandCards_S2C::cards_size() const {
  return cards_.size();
}
inline void Msg_OriginHandCards_S2C::clear_cards() {
  cards_.Clear();
}
inline const ::protocard& Msg_OriginHandCards_S2C::cards(int index) const {
  return cards_.Get(index);
}
inline ::protocard* Msg_OriginHandCards_S2C::mutable_cards(int index) {
  return cards_.Mutable(index);
}
inline ::protocard* Msg_OriginHandCards_S2C::add_cards() {
  return cards_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::protocard >&
Msg_OriginHandCards_S2C::cards() const {
  return cards_;
}
inline ::google::protobuf::RepeatedPtrField< ::protocard >*
Msg_OriginHandCards_S2C::mutable_cards() {
  return &cards_;
}

// -------------------------------------------------------------------

// Msg_GameUpdate_C2S

// required fixed32 BattleId = 1;
inline bool Msg_GameUpdate_C2S::has_battleid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Msg_GameUpdate_C2S::set_has_battleid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Msg_GameUpdate_C2S::clear_has_battleid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Msg_GameUpdate_C2S::clear_battleid() {
  battleid_ = 0u;
  clear_has_battleid();
}
inline ::google::protobuf::uint32 Msg_GameUpdate_C2S::battleid() const {
  return battleid_;
}
inline void Msg_GameUpdate_C2S::set_battleid(::google::protobuf::uint32 value) {
  set_has_battleid();
  battleid_ = value;
}

// required fixed32 Round = 2;
inline bool Msg_GameUpdate_C2S::has_round() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Msg_GameUpdate_C2S::set_has_round() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Msg_GameUpdate_C2S::clear_has_round() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Msg_GameUpdate_C2S::clear_round() {
  round_ = 0u;
  clear_has_round();
}
inline ::google::protobuf::uint32 Msg_GameUpdate_C2S::round() const {
  return round_;
}
inline void Msg_GameUpdate_C2S::set_round(::google::protobuf::uint32 value) {
  set_has_round();
  round_ = value;
}

// required .protocard useCard = 3;
inline bool Msg_GameUpdate_C2S::has_usecard() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Msg_GameUpdate_C2S::set_has_usecard() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Msg_GameUpdate_C2S::clear_has_usecard() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Msg_GameUpdate_C2S::clear_usecard() {
  if (usecard_ != NULL) usecard_->::protocard::Clear();
  clear_has_usecard();
}
inline const ::protocard& Msg_GameUpdate_C2S::usecard() const {
  return usecard_ != NULL ? *usecard_ : *default_instance_->usecard_;
}
inline ::protocard* Msg_GameUpdate_C2S::mutable_usecard() {
  set_has_usecard();
  if (usecard_ == NULL) usecard_ = new ::protocard;
  return usecard_;
}
inline ::protocard* Msg_GameUpdate_C2S::release_usecard() {
  clear_has_usecard();
  ::protocard* temp = usecard_;
  usecard_ = NULL;
  return temp;
}
inline void Msg_GameUpdate_C2S::set_allocated_usecard(::protocard* usecard) {
  delete usecard_;
  usecard_ = usecard;
  if (usecard) {
    set_has_usecard();
  } else {
    clear_has_usecard();
  }
}

// required fixed32 playerID = 4;
inline bool Msg_GameUpdate_C2S::has_playerid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Msg_GameUpdate_C2S::set_has_playerid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Msg_GameUpdate_C2S::clear_has_playerid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Msg_GameUpdate_C2S::clear_playerid() {
  playerid_ = 0u;
  clear_has_playerid();
}
inline ::google::protobuf::uint32 Msg_GameUpdate_C2S::playerid() const {
  return playerid_;
}
inline void Msg_GameUpdate_C2S::set_playerid(::google::protobuf::uint32 value) {
  set_has_playerid();
  playerid_ = value;
}

// -------------------------------------------------------------------

// Msg_GameUpdate_S2C

// required fixed32 BattleId = 1;
inline bool Msg_GameUpdate_S2C::has_battleid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Msg_GameUpdate_S2C::set_has_battleid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Msg_GameUpdate_S2C::clear_has_battleid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Msg_GameUpdate_S2C::clear_battleid() {
  battleid_ = 0u;
  clear_has_battleid();
}
inline ::google::protobuf::uint32 Msg_GameUpdate_S2C::battleid() const {
  return battleid_;
}
inline void Msg_GameUpdate_S2C::set_battleid(::google::protobuf::uint32 value) {
  set_has_battleid();
  battleid_ = value;
}

// required fixed32 player1_hp = 2;
inline bool Msg_GameUpdate_S2C::has_player1_hp() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Msg_GameUpdate_S2C::set_has_player1_hp() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Msg_GameUpdate_S2C::clear_has_player1_hp() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Msg_GameUpdate_S2C::clear_player1_hp() {
  player1_hp_ = 0u;
  clear_has_player1_hp();
}
inline ::google::protobuf::uint32 Msg_GameUpdate_S2C::player1_hp() const {
  return player1_hp_;
}
inline void Msg_GameUpdate_S2C::set_player1_hp(::google::protobuf::uint32 value) {
  set_has_player1_hp();
  player1_hp_ = value;
}

// required fixed32 player2_hp = 3;
inline bool Msg_GameUpdate_S2C::has_player2_hp() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Msg_GameUpdate_S2C::set_has_player2_hp() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Msg_GameUpdate_S2C::clear_has_player2_hp() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Msg_GameUpdate_S2C::clear_player2_hp() {
  player2_hp_ = 0u;
  clear_has_player2_hp();
}
inline ::google::protobuf::uint32 Msg_GameUpdate_S2C::player2_hp() const {
  return player2_hp_;
}
inline void Msg_GameUpdate_S2C::set_player2_hp(::google::protobuf::uint32 value) {
  set_has_player2_hp();
  player2_hp_ = value;
}

// required .protocard player1_usecard = 4;
inline bool Msg_GameUpdate_S2C::has_player1_usecard() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Msg_GameUpdate_S2C::set_has_player1_usecard() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Msg_GameUpdate_S2C::clear_has_player1_usecard() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Msg_GameUpdate_S2C::clear_player1_usecard() {
  if (player1_usecard_ != NULL) player1_usecard_->::protocard::Clear();
  clear_has_player1_usecard();
}
inline const ::protocard& Msg_GameUpdate_S2C::player1_usecard() const {
  return player1_usecard_ != NULL ? *player1_usecard_ : *default_instance_->player1_usecard_;
}
inline ::protocard* Msg_GameUpdate_S2C::mutable_player1_usecard() {
  set_has_player1_usecard();
  if (player1_usecard_ == NULL) player1_usecard_ = new ::protocard;
  return player1_usecard_;
}
inline ::protocard* Msg_GameUpdate_S2C::release_player1_usecard() {
  clear_has_player1_usecard();
  ::protocard* temp = player1_usecard_;
  player1_usecard_ = NULL;
  return temp;
}
inline void Msg_GameUpdate_S2C::set_allocated_player1_usecard(::protocard* player1_usecard) {
  delete player1_usecard_;
  player1_usecard_ = player1_usecard;
  if (player1_usecard) {
    set_has_player1_usecard();
  } else {
    clear_has_player1_usecard();
  }
}

// required .protocard player2_usecard = 5;
inline bool Msg_GameUpdate_S2C::has_player2_usecard() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Msg_GameUpdate_S2C::set_has_player2_usecard() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Msg_GameUpdate_S2C::clear_has_player2_usecard() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Msg_GameUpdate_S2C::clear_player2_usecard() {
  if (player2_usecard_ != NULL) player2_usecard_->::protocard::Clear();
  clear_has_player2_usecard();
}
inline const ::protocard& Msg_GameUpdate_S2C::player2_usecard() const {
  return player2_usecard_ != NULL ? *player2_usecard_ : *default_instance_->player2_usecard_;
}
inline ::protocard* Msg_GameUpdate_S2C::mutable_player2_usecard() {
  set_has_player2_usecard();
  if (player2_usecard_ == NULL) player2_usecard_ = new ::protocard;
  return player2_usecard_;
}
inline ::protocard* Msg_GameUpdate_S2C::release_player2_usecard() {
  clear_has_player2_usecard();
  ::protocard* temp = player2_usecard_;
  player2_usecard_ = NULL;
  return temp;
}
inline void Msg_GameUpdate_S2C::set_allocated_player2_usecard(::protocard* player2_usecard) {
  delete player2_usecard_;
  player2_usecard_ = player2_usecard;
  if (player2_usecard) {
    set_has_player2_usecard();
  } else {
    clear_has_player2_usecard();
  }
}

// optional .protocard player1_gotCard = 6;
inline bool Msg_GameUpdate_S2C::has_player1_gotcard() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Msg_GameUpdate_S2C::set_has_player1_gotcard() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Msg_GameUpdate_S2C::clear_has_player1_gotcard() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Msg_GameUpdate_S2C::clear_player1_gotcard() {
  if (player1_gotcard_ != NULL) player1_gotcard_->::protocard::Clear();
  clear_has_player1_gotcard();
}
inline const ::protocard& Msg_GameUpdate_S2C::player1_gotcard() const {
  return player1_gotcard_ != NULL ? *player1_gotcard_ : *default_instance_->player1_gotcard_;
}
inline ::protocard* Msg_GameUpdate_S2C::mutable_player1_gotcard() {
  set_has_player1_gotcard();
  if (player1_gotcard_ == NULL) player1_gotcard_ = new ::protocard;
  return player1_gotcard_;
}
inline ::protocard* Msg_GameUpdate_S2C::release_player1_gotcard() {
  clear_has_player1_gotcard();
  ::protocard* temp = player1_gotcard_;
  player1_gotcard_ = NULL;
  return temp;
}
inline void Msg_GameUpdate_S2C::set_allocated_player1_gotcard(::protocard* player1_gotcard) {
  delete player1_gotcard_;
  player1_gotcard_ = player1_gotcard;
  if (player1_gotcard) {
    set_has_player1_gotcard();
  } else {
    clear_has_player1_gotcard();
  }
}

// optional .protocard player2_gotCard = 7;
inline bool Msg_GameUpdate_S2C::has_player2_gotcard() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Msg_GameUpdate_S2C::set_has_player2_gotcard() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Msg_GameUpdate_S2C::clear_has_player2_gotcard() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Msg_GameUpdate_S2C::clear_player2_gotcard() {
  if (player2_gotcard_ != NULL) player2_gotcard_->::protocard::Clear();
  clear_has_player2_gotcard();
}
inline const ::protocard& Msg_GameUpdate_S2C::player2_gotcard() const {
  return player2_gotcard_ != NULL ? *player2_gotcard_ : *default_instance_->player2_gotcard_;
}
inline ::protocard* Msg_GameUpdate_S2C::mutable_player2_gotcard() {
  set_has_player2_gotcard();
  if (player2_gotcard_ == NULL) player2_gotcard_ = new ::protocard;
  return player2_gotcard_;
}
inline ::protocard* Msg_GameUpdate_S2C::release_player2_gotcard() {
  clear_has_player2_gotcard();
  ::protocard* temp = player2_gotcard_;
  player2_gotcard_ = NULL;
  return temp;
}
inline void Msg_GameUpdate_S2C::set_allocated_player2_gotcard(::protocard* player2_gotcard) {
  delete player2_gotcard_;
  player2_gotcard_ = player2_gotcard;
  if (player2_gotcard) {
    set_has_player2_gotcard();
  } else {
    clear_has_player2_gotcard();
  }
}

// -------------------------------------------------------------------

// Msg_Surrender_C2S

// required fixed32 ID = 1;
inline bool Msg_Surrender_C2S::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Msg_Surrender_C2S::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Msg_Surrender_C2S::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Msg_Surrender_C2S::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 Msg_Surrender_C2S::id() const {
  return id_;
}
inline void Msg_Surrender_C2S::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
}

// required fixed32 BattleId = 2;
inline bool Msg_Surrender_C2S::has_battleid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Msg_Surrender_C2S::set_has_battleid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Msg_Surrender_C2S::clear_has_battleid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Msg_Surrender_C2S::clear_battleid() {
  battleid_ = 0u;
  clear_has_battleid();
}
inline ::google::protobuf::uint32 Msg_Surrender_C2S::battleid() const {
  return battleid_;
}
inline void Msg_Surrender_C2S::set_battleid(::google::protobuf::uint32 value) {
  set_has_battleid();
  battleid_ = value;
}

// -------------------------------------------------------------------

// Msg_Gameover_S2C

// required fixed32 BattleId = 1;
inline bool Msg_Gameover_S2C::has_battleid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Msg_Gameover_S2C::set_has_battleid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Msg_Gameover_S2C::clear_has_battleid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Msg_Gameover_S2C::clear_battleid() {
  battleid_ = 0u;
  clear_has_battleid();
}
inline ::google::protobuf::uint32 Msg_Gameover_S2C::battleid() const {
  return battleid_;
}
inline void Msg_Gameover_S2C::set_battleid(::google::protobuf::uint32 value) {
  set_has_battleid();
  battleid_ = value;
}

// required fixed32 player1_id = 2;
inline bool Msg_Gameover_S2C::has_player1_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Msg_Gameover_S2C::set_has_player1_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Msg_Gameover_S2C::clear_has_player1_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Msg_Gameover_S2C::clear_player1_id() {
  player1_id_ = 0u;
  clear_has_player1_id();
}
inline ::google::protobuf::uint32 Msg_Gameover_S2C::player1_id() const {
  return player1_id_;
}
inline void Msg_Gameover_S2C::set_player1_id(::google::protobuf::uint32 value) {
  set_has_player1_id();
  player1_id_ = value;
}

// required fixed32 player2_id = 3;
inline bool Msg_Gameover_S2C::has_player2_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Msg_Gameover_S2C::set_has_player2_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Msg_Gameover_S2C::clear_has_player2_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Msg_Gameover_S2C::clear_player2_id() {
  player2_id_ = 0u;
  clear_has_player2_id();
}
inline ::google::protobuf::uint32 Msg_Gameover_S2C::player2_id() const {
  return player2_id_;
}
inline void Msg_Gameover_S2C::set_player2_id(::google::protobuf::uint32 value) {
  set_has_player2_id();
  player2_id_ = value;
}

// required bool player1_victory = 4;
inline bool Msg_Gameover_S2C::has_player1_victory() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Msg_Gameover_S2C::set_has_player1_victory() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Msg_Gameover_S2C::clear_has_player1_victory() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Msg_Gameover_S2C::clear_player1_victory() {
  player1_victory_ = false;
  clear_has_player1_victory();
}
inline bool Msg_Gameover_S2C::player1_victory() const {
  return player1_victory_;
}
inline void Msg_Gameover_S2C::set_player1_victory(bool value) {
  set_has_player1_victory();
  player1_victory_ = value;
}

// required bool player2_victory = 5;
inline bool Msg_Gameover_S2C::has_player2_victory() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Msg_Gameover_S2C::set_has_player2_victory() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Msg_Gameover_S2C::clear_has_player2_victory() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Msg_Gameover_S2C::clear_player2_victory() {
  player2_victory_ = false;
  clear_has_player2_victory();
}
inline bool Msg_Gameover_S2C::player2_victory() const {
  return player2_victory_;
}
inline void Msg_Gameover_S2C::set_player2_victory(bool value) {
  set_has_player2_victory();
  player2_victory_ = value;
}

// -------------------------------------------------------------------

// Msg_RoomList_S2C

// repeated .protoRoom rooms = 1;
inline int Msg_RoomList_S2C::rooms_size() const {
  return rooms_.size();
}
inline void Msg_RoomList_S2C::clear_rooms() {
  rooms_.Clear();
}
inline const ::protoRoom& Msg_RoomList_S2C::rooms(int index) const {
  return rooms_.Get(index);
}
inline ::protoRoom* Msg_RoomList_S2C::mutable_rooms(int index) {
  return rooms_.Mutable(index);
}
inline ::protoRoom* Msg_RoomList_S2C::add_rooms() {
  return rooms_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::protoRoom >&
Msg_RoomList_S2C::rooms() const {
  return rooms_;
}
inline ::google::protobuf::RepeatedPtrField< ::protoRoom >*
Msg_RoomList_S2C::mutable_rooms() {
  return &rooms_;
}

// -------------------------------------------------------------------

// Msg_AccountMsg_C2S

// required fixed32 requestid = 1;
inline bool Msg_AccountMsg_C2S::has_requestid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Msg_AccountMsg_C2S::set_has_requestid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Msg_AccountMsg_C2S::clear_has_requestid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Msg_AccountMsg_C2S::clear_requestid() {
  requestid_ = 0u;
  clear_has_requestid();
}
inline ::google::protobuf::uint32 Msg_AccountMsg_C2S::requestid() const {
  return requestid_;
}
inline void Msg_AccountMsg_C2S::set_requestid(::google::protobuf::uint32 value) {
  set_has_requestid();
  requestid_ = value;
}

// required bool get = 2;
inline bool Msg_AccountMsg_C2S::has_get() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Msg_AccountMsg_C2S::set_has_get() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Msg_AccountMsg_C2S::clear_has_get() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Msg_AccountMsg_C2S::clear_get() {
  get_ = false;
  clear_has_get();
}
inline bool Msg_AccountMsg_C2S::get() const {
  return get_;
}
inline void Msg_AccountMsg_C2S::set_get(bool value) {
  set_has_get();
  get_ = value;
}

// optional string headImg = 3;
inline bool Msg_AccountMsg_C2S::has_headimg() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Msg_AccountMsg_C2S::set_has_headimg() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Msg_AccountMsg_C2S::clear_has_headimg() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Msg_AccountMsg_C2S::clear_headimg() {
  if (headimg_ != &::google::protobuf::internal::kEmptyString) {
    headimg_->clear();
  }
  clear_has_headimg();
}
inline const ::std::string& Msg_AccountMsg_C2S::headimg() const {
  return *headimg_;
}
inline void Msg_AccountMsg_C2S::set_headimg(const ::std::string& value) {
  set_has_headimg();
  if (headimg_ == &::google::protobuf::internal::kEmptyString) {
    headimg_ = new ::std::string;
  }
  headimg_->assign(value);
}
inline void Msg_AccountMsg_C2S::set_headimg(const char* value) {
  set_has_headimg();
  if (headimg_ == &::google::protobuf::internal::kEmptyString) {
    headimg_ = new ::std::string;
  }
  headimg_->assign(value);
}
inline void Msg_AccountMsg_C2S::set_headimg(const char* value, size_t size) {
  set_has_headimg();
  if (headimg_ == &::google::protobuf::internal::kEmptyString) {
    headimg_ = new ::std::string;
  }
  headimg_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Msg_AccountMsg_C2S::mutable_headimg() {
  set_has_headimg();
  if (headimg_ == &::google::protobuf::internal::kEmptyString) {
    headimg_ = new ::std::string;
  }
  return headimg_;
}
inline ::std::string* Msg_AccountMsg_C2S::release_headimg() {
  clear_has_headimg();
  if (headimg_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = headimg_;
    headimg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Msg_AccountMsg_C2S::set_allocated_headimg(::std::string* headimg) {
  if (headimg_ != &::google::protobuf::internal::kEmptyString) {
    delete headimg_;
  }
  if (headimg) {
    set_has_headimg();
    headimg_ = headimg;
  } else {
    clear_has_headimg();
    headimg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// Msg_AccountMsg_S2C

// optional .protoaccount account = 1;
inline bool Msg_AccountMsg_S2C::has_account() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Msg_AccountMsg_S2C::set_has_account() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Msg_AccountMsg_S2C::clear_has_account() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Msg_AccountMsg_S2C::clear_account() {
  if (account_ != NULL) account_->::protoaccount::Clear();
  clear_has_account();
}
inline const ::protoaccount& Msg_AccountMsg_S2C::account() const {
  return account_ != NULL ? *account_ : *default_instance_->account_;
}
inline ::protoaccount* Msg_AccountMsg_S2C::mutable_account() {
  set_has_account();
  if (account_ == NULL) account_ = new ::protoaccount;
  return account_;
}
inline ::protoaccount* Msg_AccountMsg_S2C::release_account() {
  clear_has_account();
  ::protoaccount* temp = account_;
  account_ = NULL;
  return temp;
}
inline void Msg_AccountMsg_S2C::set_allocated_account(::protoaccount* account) {
  delete account_;
  account_ = account;
  if (account) {
    set_has_account();
  } else {
    clear_has_account();
  }
}

// -------------------------------------------------------------------

// protoaccount

// optional string name = 1;
inline bool protoaccount::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void protoaccount::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void protoaccount::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void protoaccount::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& protoaccount::name() const {
  return *name_;
}
inline void protoaccount::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void protoaccount::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void protoaccount::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* protoaccount::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* protoaccount::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void protoaccount::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional fixed32 Score = 2;
inline bool protoaccount::has_score() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void protoaccount::set_has_score() {
  _has_bits_[0] |= 0x00000002u;
}
inline void protoaccount::clear_has_score() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void protoaccount::clear_score() {
  score_ = 0u;
  clear_has_score();
}
inline ::google::protobuf::uint32 protoaccount::score() const {
  return score_;
}
inline void protoaccount::set_score(::google::protobuf::uint32 value) {
  set_has_score();
  score_ = value;
}

// optional fixed32 BattleNums = 3;
inline bool protoaccount::has_battlenums() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void protoaccount::set_has_battlenums() {
  _has_bits_[0] |= 0x00000004u;
}
inline void protoaccount::clear_has_battlenums() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void protoaccount::clear_battlenums() {
  battlenums_ = 0u;
  clear_has_battlenums();
}
inline ::google::protobuf::uint32 protoaccount::battlenums() const {
  return battlenums_;
}
inline void protoaccount::set_battlenums(::google::protobuf::uint32 value) {
  set_has_battlenums();
  battlenums_ = value;
}

// optional fixed32 StandardBattles = 4;
inline bool protoaccount::has_standardbattles() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void protoaccount::set_has_standardbattles() {
  _has_bits_[0] |= 0x00000008u;
}
inline void protoaccount::clear_has_standardbattles() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void protoaccount::clear_standardbattles() {
  standardbattles_ = 0u;
  clear_has_standardbattles();
}
inline ::google::protobuf::uint32 protoaccount::standardbattles() const {
  return standardbattles_;
}
inline void protoaccount::set_standardbattles(::google::protobuf::uint32 value) {
  set_has_standardbattles();
  standardbattles_ = value;
}

// optional fixed32 RankBattles = 5;
inline bool protoaccount::has_rankbattles() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void protoaccount::set_has_rankbattles() {
  _has_bits_[0] |= 0x00000010u;
}
inline void protoaccount::clear_has_rankbattles() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void protoaccount::clear_rankbattles() {
  rankbattles_ = 0u;
  clear_has_rankbattles();
}
inline ::google::protobuf::uint32 protoaccount::rankbattles() const {
  return rankbattles_;
}
inline void protoaccount::set_rankbattles(::google::protobuf::uint32 value) {
  set_has_rankbattles();
  rankbattles_ = value;
}

// optional fixed32 BattleWins = 6;
inline bool protoaccount::has_battlewins() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void protoaccount::set_has_battlewins() {
  _has_bits_[0] |= 0x00000020u;
}
inline void protoaccount::clear_has_battlewins() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void protoaccount::clear_battlewins() {
  battlewins_ = 0u;
  clear_has_battlewins();
}
inline ::google::protobuf::uint32 protoaccount::battlewins() const {
  return battlewins_;
}
inline void protoaccount::set_battlewins(::google::protobuf::uint32 value) {
  set_has_battlewins();
  battlewins_ = value;
}

// optional fixed32 StandardWins = 7;
inline bool protoaccount::has_standardwins() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void protoaccount::set_has_standardwins() {
  _has_bits_[0] |= 0x00000040u;
}
inline void protoaccount::clear_has_standardwins() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void protoaccount::clear_standardwins() {
  standardwins_ = 0u;
  clear_has_standardwins();
}
inline ::google::protobuf::uint32 protoaccount::standardwins() const {
  return standardwins_;
}
inline void protoaccount::set_standardwins(::google::protobuf::uint32 value) {
  set_has_standardwins();
  standardwins_ = value;
}

// optional fixed32 RankWins = 8;
inline bool protoaccount::has_rankwins() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void protoaccount::set_has_rankwins() {
  _has_bits_[0] |= 0x00000080u;
}
inline void protoaccount::clear_has_rankwins() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void protoaccount::clear_rankwins() {
  rankwins_ = 0u;
  clear_has_rankwins();
}
inline ::google::protobuf::uint32 protoaccount::rankwins() const {
  return rankwins_;
}
inline void protoaccount::set_rankwins(::google::protobuf::uint32 value) {
  set_has_rankwins();
  rankwins_ = value;
}

// optional string title = 9;
inline bool protoaccount::has_title() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void protoaccount::set_has_title() {
  _has_bits_[0] |= 0x00000100u;
}
inline void protoaccount::clear_has_title() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void protoaccount::clear_title() {
  if (title_ != &::google::protobuf::internal::kEmptyString) {
    title_->clear();
  }
  clear_has_title();
}
inline const ::std::string& protoaccount::title() const {
  return *title_;
}
inline void protoaccount::set_title(const ::std::string& value) {
  set_has_title();
  if (title_ == &::google::protobuf::internal::kEmptyString) {
    title_ = new ::std::string;
  }
  title_->assign(value);
}
inline void protoaccount::set_title(const char* value) {
  set_has_title();
  if (title_ == &::google::protobuf::internal::kEmptyString) {
    title_ = new ::std::string;
  }
  title_->assign(value);
}
inline void protoaccount::set_title(const char* value, size_t size) {
  set_has_title();
  if (title_ == &::google::protobuf::internal::kEmptyString) {
    title_ = new ::std::string;
  }
  title_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* protoaccount::mutable_title() {
  set_has_title();
  if (title_ == &::google::protobuf::internal::kEmptyString) {
    title_ = new ::std::string;
  }
  return title_;
}
inline ::std::string* protoaccount::release_title() {
  clear_has_title();
  if (title_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = title_;
    title_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void protoaccount::set_allocated_title(::std::string* title) {
  if (title_ != &::google::protobuf::internal::kEmptyString) {
    delete title_;
  }
  if (title) {
    set_has_title();
    title_ = title;
  } else {
    clear_has_title();
    title_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string HeadImg = 10;
inline bool protoaccount::has_headimg() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void protoaccount::set_has_headimg() {
  _has_bits_[0] |= 0x00000200u;
}
inline void protoaccount::clear_has_headimg() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void protoaccount::clear_headimg() {
  if (headimg_ != &::google::protobuf::internal::kEmptyString) {
    headimg_->clear();
  }
  clear_has_headimg();
}
inline const ::std::string& protoaccount::headimg() const {
  return *headimg_;
}
inline void protoaccount::set_headimg(const ::std::string& value) {
  set_has_headimg();
  if (headimg_ == &::google::protobuf::internal::kEmptyString) {
    headimg_ = new ::std::string;
  }
  headimg_->assign(value);
}
inline void protoaccount::set_headimg(const char* value) {
  set_has_headimg();
  if (headimg_ == &::google::protobuf::internal::kEmptyString) {
    headimg_ = new ::std::string;
  }
  headimg_->assign(value);
}
inline void protoaccount::set_headimg(const char* value, size_t size) {
  set_has_headimg();
  if (headimg_ == &::google::protobuf::internal::kEmptyString) {
    headimg_ = new ::std::string;
  }
  headimg_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* protoaccount::mutable_headimg() {
  set_has_headimg();
  if (headimg_ == &::google::protobuf::internal::kEmptyString) {
    headimg_ = new ::std::string;
  }
  return headimg_;
}
inline ::std::string* protoaccount::release_headimg() {
  clear_has_headimg();
  if (headimg_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = headimg_;
    headimg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void protoaccount::set_allocated_headimg(::std::string* headimg) {
  if (headimg_ != &::google::protobuf::internal::kEmptyString) {
    delete headimg_;
  }
  if (headimg) {
    set_has_headimg();
    headimg_ = headimg;
  } else {
    clear_has_headimg();
    headimg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// protocard

// required fixed32 card_id = 1;
inline bool protocard::has_card_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void protocard::set_has_card_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void protocard::clear_has_card_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void protocard::clear_card_id() {
  card_id_ = 0u;
  clear_has_card_id();
}
inline ::google::protobuf::uint32 protocard::card_id() const {
  return card_id_;
}
inline void protocard::set_card_id(::google::protobuf::uint32 value) {
  set_has_card_id();
  card_id_ = value;
}

// required .CardAttribute card_attribute = 2;
inline bool protocard::has_card_attribute() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void protocard::set_has_card_attribute() {
  _has_bits_[0] |= 0x00000002u;
}
inline void protocard::clear_has_card_attribute() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void protocard::clear_card_attribute() {
  card_attribute_ = 0;
  clear_has_card_attribute();
}
inline ::CardAttribute protocard::card_attribute() const {
  return static_cast< ::CardAttribute >(card_attribute_);
}
inline void protocard::set_card_attribute(::CardAttribute value) {
  assert(::CardAttribute_IsValid(value));
  set_has_card_attribute();
  card_attribute_ = value;
}

// required fixed32 card_type = 3;
inline bool protocard::has_card_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void protocard::set_has_card_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void protocard::clear_has_card_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void protocard::clear_card_type() {
  card_type_ = 0u;
  clear_has_card_type();
}
inline ::google::protobuf::uint32 protocard::card_type() const {
  return card_type_;
}
inline void protocard::set_card_type(::google::protobuf::uint32 value) {
  set_has_card_type();
  card_type_ = value;
}

// required fixed32 card_value = 4;
inline bool protocard::has_card_value() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void protocard::set_has_card_value() {
  _has_bits_[0] |= 0x00000008u;
}
inline void protocard::clear_has_card_value() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void protocard::clear_card_value() {
  card_value_ = 0u;
  clear_has_card_value();
}
inline ::google::protobuf::uint32 protocard::card_value() const {
  return card_value_;
}
inline void protocard::set_card_value(::google::protobuf::uint32 value) {
  set_has_card_value();
  card_value_ = value;
}

// optional string card_image = 5;
inline bool protocard::has_card_image() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void protocard::set_has_card_image() {
  _has_bits_[0] |= 0x00000010u;
}
inline void protocard::clear_has_card_image() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void protocard::clear_card_image() {
  if (card_image_ != &::google::protobuf::internal::kEmptyString) {
    card_image_->clear();
  }
  clear_has_card_image();
}
inline const ::std::string& protocard::card_image() const {
  return *card_image_;
}
inline void protocard::set_card_image(const ::std::string& value) {
  set_has_card_image();
  if (card_image_ == &::google::protobuf::internal::kEmptyString) {
    card_image_ = new ::std::string;
  }
  card_image_->assign(value);
}
inline void protocard::set_card_image(const char* value) {
  set_has_card_image();
  if (card_image_ == &::google::protobuf::internal::kEmptyString) {
    card_image_ = new ::std::string;
  }
  card_image_->assign(value);
}
inline void protocard::set_card_image(const char* value, size_t size) {
  set_has_card_image();
  if (card_image_ == &::google::protobuf::internal::kEmptyString) {
    card_image_ = new ::std::string;
  }
  card_image_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* protocard::mutable_card_image() {
  set_has_card_image();
  if (card_image_ == &::google::protobuf::internal::kEmptyString) {
    card_image_ = new ::std::string;
  }
  return card_image_;
}
inline ::std::string* protocard::release_card_image() {
  clear_has_card_image();
  if (card_image_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = card_image_;
    card_image_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void protocard::set_allocated_card_image(::std::string* card_image) {
  if (card_image_ != &::google::protobuf::internal::kEmptyString) {
    delete card_image_;
  }
  if (card_image) {
    set_has_card_image();
    card_image_ = card_image;
  } else {
    clear_has_card_image();
    card_image_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional fixed32 imgID = 6;
inline bool protocard::has_imgid() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void protocard::set_has_imgid() {
  _has_bits_[0] |= 0x00000020u;
}
inline void protocard::clear_has_imgid() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void protocard::clear_imgid() {
  imgid_ = 0u;
  clear_has_imgid();
}
inline ::google::protobuf::uint32 protocard::imgid() const {
  return imgid_;
}
inline void protocard::set_imgid(::google::protobuf::uint32 value) {
  set_has_imgid();
  imgid_ = value;
}

// -------------------------------------------------------------------

// protoRoom

// required fixed32 room_id = 1;
inline bool protoRoom::has_room_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void protoRoom::set_has_room_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void protoRoom::clear_has_room_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void protoRoom::clear_room_id() {
  room_id_ = 0u;
  clear_has_room_id();
}
inline ::google::protobuf::uint32 protoRoom::room_id() const {
  return room_id_;
}
inline void protoRoom::set_room_id(::google::protobuf::uint32 value) {
  set_has_room_id();
  room_id_ = value;
}

// required string room_name = 2;
inline bool protoRoom::has_room_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void protoRoom::set_has_room_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void protoRoom::clear_has_room_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void protoRoom::clear_room_name() {
  if (room_name_ != &::google::protobuf::internal::kEmptyString) {
    room_name_->clear();
  }
  clear_has_room_name();
}
inline const ::std::string& protoRoom::room_name() const {
  return *room_name_;
}
inline void protoRoom::set_room_name(const ::std::string& value) {
  set_has_room_name();
  if (room_name_ == &::google::protobuf::internal::kEmptyString) {
    room_name_ = new ::std::string;
  }
  room_name_->assign(value);
}
inline void protoRoom::set_room_name(const char* value) {
  set_has_room_name();
  if (room_name_ == &::google::protobuf::internal::kEmptyString) {
    room_name_ = new ::std::string;
  }
  room_name_->assign(value);
}
inline void protoRoom::set_room_name(const char* value, size_t size) {
  set_has_room_name();
  if (room_name_ == &::google::protobuf::internal::kEmptyString) {
    room_name_ = new ::std::string;
  }
  room_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* protoRoom::mutable_room_name() {
  set_has_room_name();
  if (room_name_ == &::google::protobuf::internal::kEmptyString) {
    room_name_ = new ::std::string;
  }
  return room_name_;
}
inline ::std::string* protoRoom::release_room_name() {
  clear_has_room_name();
  if (room_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = room_name_;
    room_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void protoRoom::set_allocated_room_name(::std::string* room_name) {
  if (room_name_ != &::google::protobuf::internal::kEmptyString) {
    delete room_name_;
  }
  if (room_name) {
    set_has_room_name();
    room_name_ = room_name;
  } else {
    clear_has_room_name();
    room_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required fixed32 room_users = 3;
inline bool protoRoom::has_room_users() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void protoRoom::set_has_room_users() {
  _has_bits_[0] |= 0x00000004u;
}
inline void protoRoom::clear_has_room_users() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void protoRoom::clear_room_users() {
  room_users_ = 0u;
  clear_has_room_users();
}
inline ::google::protobuf::uint32 protoRoom::room_users() const {
  return room_users_;
}
inline void protoRoom::set_room_users(::google::protobuf::uint32 value) {
  set_has_room_users();
  room_users_ = value;
}

// required .GamePattern roompattern = 4;
inline bool protoRoom::has_roompattern() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void protoRoom::set_has_roompattern() {
  _has_bits_[0] |= 0x00000008u;
}
inline void protoRoom::clear_has_roompattern() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void protoRoom::clear_roompattern() {
  roompattern_ = 0;
  clear_has_roompattern();
}
inline ::GamePattern protoRoom::roompattern() const {
  return static_cast< ::GamePattern >(roompattern_);
}
inline void protoRoom::set_roompattern(::GamePattern value) {
  assert(::GamePattern_IsValid(value));
  set_has_roompattern();
  roompattern_ = value;
}

// optional string map = 5;
inline bool protoRoom::has_map() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void protoRoom::set_has_map() {
  _has_bits_[0] |= 0x00000010u;
}
inline void protoRoom::clear_has_map() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void protoRoom::clear_map() {
  if (map_ != &::google::protobuf::internal::kEmptyString) {
    map_->clear();
  }
  clear_has_map();
}
inline const ::std::string& protoRoom::map() const {
  return *map_;
}
inline void protoRoom::set_map(const ::std::string& value) {
  set_has_map();
  if (map_ == &::google::protobuf::internal::kEmptyString) {
    map_ = new ::std::string;
  }
  map_->assign(value);
}
inline void protoRoom::set_map(const char* value) {
  set_has_map();
  if (map_ == &::google::protobuf::internal::kEmptyString) {
    map_ = new ::std::string;
  }
  map_->assign(value);
}
inline void protoRoom::set_map(const char* value, size_t size) {
  set_has_map();
  if (map_ == &::google::protobuf::internal::kEmptyString) {
    map_ = new ::std::string;
  }
  map_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* protoRoom::mutable_map() {
  set_has_map();
  if (map_ == &::google::protobuf::internal::kEmptyString) {
    map_ = new ::std::string;
  }
  return map_;
}
inline ::std::string* protoRoom::release_map() {
  clear_has_map();
  if (map_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = map_;
    map_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void protoRoom::set_allocated_map(::std::string* map) {
  if (map_ != &::google::protobuf::internal::kEmptyString) {
    delete map_;
  }
  if (map) {
    set_has_map();
    map_ = map;
  } else {
    clear_has_map();
    map_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}


// @@protoc_insertion_point(namespace_scope)

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::GamePattern>() {
  return ::GamePattern_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::CardAttribute>() {
  return ::CardAttribute_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::MsgType>() {
  return ::MsgType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::RoomOperateType>() {
  return ::RoomOperateType_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_Msg_2eproto__INCLUDED
